#! /usr/bin/make -f
############################ -*- Mode: Makefile -*- ###########################
## debian.rules ---
## Author	    : Manoj Srivastava ( srivasta@pilgrim.umass.edu )
## Created On	    : Sat Apr 27 06:36:31 1996
## Created On Node  : melkor.pilgrim.umass.edu
## Last Modified By : Manoj Srivastava
## Last Modified On : Tue Apr 20 20:46:15 2004
## Last Machine Used: glaurung.internal.golden-gryphon.com
## Update Count	    : 678
## Status	    : Unknown, Use with caution!
## HISTORY	    :
## Description	    :
## arch-tag: aa70d4e5-79bf-405c-95ec-5fa9f7ae7b69
###############################################################################

ifdef KPKG_ARCH
  ifneq ($(strip $(KPKG_ARCH)),um)
    ha:=-a$(KPKG_ARCH)
  endif
endif

DPKG_ARCH := dpkg-architecture
# set the dpkg-architecture vars
export DEB_BUILD_ARCH      := $(shell $(DPKG_ARCH) $(ha) -qDEB_BUILD_ARCH)
export DEB_BUILD_GNU_CPU   := $(shell $(DPKG_ARCH) $(ha) -qDEB_BUILD_GNU_CPU)
export DEB_BUILD_GNU_TYPE  := $(shell $(DPKG_ARCH) $(ha) -qDEB_BUILD_GNU_TYPE)
export DEB_HOST_ARCH       := $(shell $(DPKG_ARCH) $(ha) -qDEB_HOST_ARCH)
export DEB_HOST_GNU_CPU    := $(shell $(DPKG_ARCH) $(ha) -qDEB_HOST_GNU_CPU)
export DEB_HOST_GNU_SYSTEM := $(shell $(DPKG_ARCH) $(ha) -qDEB_HOST_GNU_SYSTEM)
export DEB_HOST_GNU_TYPE   := $(shell $(DPKG_ARCH) $(ha) -qDEB_HOST_GNU_TYPE)
export DEB_BUILD_GNU_SYSTEM:= $(shell $(DPKG_ARCH) $(ha) -qDEB_BUILD_GNU_SYSTEM)

#
# VERSION=$(shell LC_ALL=C dpkg-parsechangelog | grep ^Version: | \
#                          sed 's/^Version: *//')
#

# The version of kernel-package this belongs to
kpkg_version := =K=V

# The maintainer information.
maintainer = Herbert Xu
email= herbert@greathan.apana.org.au

pgp=$(maintainer)


#  Package specific stuff
# decide if image is meant to be in /boot rather than /
link_in_boot :=
# Can we use symlinks?
no_symlink :=
# If so, where is the real file (usually, vmlinuz-X.X.X is real, and
# vmlinuz is the link, this variable reverses it.
reverse_symlink :=

# The version numbers for kernel-image, kernel-headers and
# kernel-source are deduced from the Makefile (see below,
# and footnote 1 for details)

# Whether to look for and install kernel patches by default.
# Be very careful if you do this.
patch_the_kernel := AUTO

# do not create libc headers by default
make_libc_headers := NO

# run make clean after build
do_clean := NO

# install uncompressed kernel ELF-image (for oprofile)
int_install_vmlinux := NO

# what kernel config target to run in our configure target.
config_target := oldconfig


# The default architecture (all if architecture independent)
CROSS_ARG:=

ifdef KPKG_ARCH
  architecture:=$(KPKG_ARCH)
else
  #architecture:=$(shell CC=$(HOSTCC) dpkg --print-gnu-build-architecture)
  architecture:=$(DEB_HOST_ARCH)
endif

ifndef CROSS_COMPILE
  ifneq ($(strip $(KPKG_ARCH)),um)
    ifneq ($(strip $(architecture)),$(strip $(DEB_BUILD_ARCH)))
      KERNEL_CROSS:=$(architecture)-$(strip $(DEB_HOST_GNU_SYSTEM))-
    endif
  endif
else
  KERNEL_CROSS:=$(CROSS_COMPILE)-
endif

ifneq ($(strip $(KERNEL_CROSS)),)
  CROSS_ARG:=CROSS_COMPILE=$(KERNEL_CROSS)
endif

KERNEL_ARCH:=$(architecture)
DEBCONFIG = $(CONFDIR)/config
IMAGEDIR=/boot
INT_IMAGE_DESTDIR=debian/tmp-image$(IMAGEDIR)


VERSION =$(shell egrep '^VERSION +=' Makefile 2>/dev/null | \
 sed -e 's/[^0-9]*\([0-9]*\)/\1/')
PATCHLEVEL =$(shell egrep '^PATCHLEVEL +=' Makefile 2>/dev/null | \
 sed -e 's/[^0-9]*\([0-9]*\)/\1/')
SUBLEVEL =$(shell egrep '^SUBLEVEL +=' Makefile 2>/dev/null | \
 sed -e 's/[^0-9]*\([0-9]*\)/\1/')
EXTRA_VERSION =$(shell egrep '^EXTRAVERSION +=' Makefile 2>/dev/null | \
 sed -e 's/EXTRAVERSION *= *\([^ \t]*\)/\1/')
HAVE_NEW_MODLIB =$(shell egrep '\(INSTALL_MOD_PATH\)' Makefile 2>/dev/null )

ifneq ($(strip $(EXTRA_VERSION)),)
HAS_ILLEGAL_EXTRA_VERSION =$(shell                         \
    perl -e '$$i="$(EXTRA_VERSION)"; $$i !~ m/^[a-z\.\-\+][a-z\d\.\-\+]*$$/o && print YES;')
  ifneq ($(strip $(HAS_ILLEGAL_EXTRA_VERSION)),)
    $(error Error: The EXTRAVERSION may only contain lowercase alphanumerics \
 and  the  characters  - +  . The current value is: $(EXTRA_VERSION). Aborting.)
  endif
endif

AM_OFFICIAL := $(shell if [ -f debian/official ]; then echo YES; fi )

######################################################################
###          Architecture specific stuff                           ###
######################################################################
# Each architecture has the following specified for it
# (a) The kernel image type (i.e. zImage or bzImage)
# (b) The dependency on a loader, if any
# (c) The name of the loader
# (d) The name of the documentation file for the loader
# (e) The build target
# (f) The location of the kernelimage source
# (g) The location of the kernelimage destination
# (h) The name of the arch specific configuration file
# Some architectures has sub architectures

### m68k
ifeq ($(strip $(architecture)),m68k)
  ifeq (,$(findstring /$(KPKG_SUBARCH)/,/amiga/atari/mac/mvme147/mvme16x/bvme6000/))
    GUESS_SUBARCH:=$(shell awk '/Model/ { print $$2}' /proc/hardware)
    ifneq (,$(findstring Motorola,$(GUESS_SUBARCH)))
     GUESS_SUBARCH:=$(shell awk '/Model/ { print $$3}' /proc/hardware)
     ifneq (,$(findstring MVME147,$(GUESS_SUBARCH)))
      KPKG_SUBARCH:=mvme147
     else
      KPKG_SUBARCH:=mvme16x
     endif
    else
     ifneq (,$(findstring BVME,$(GUESS_SUBARCH)))
      KPKG_SUBARCH:=bvme6000
     else
      ifneq (,$(findstring Amiga,$(GUESS_SUBARCH)))
       KPKG_SUBARCH:=amiga
      else
       ifneq (,$(findstring Atari,$(GUESS_SUBARCH)))
        KPKG_SUBARCH:=atari
       else
        ifneq (,$(findstring Mac,$(GUESS_SUBARCH)))
         KPKG_SUBARCH:=mac
        endif
       endif
      endif
     endif
    endif
  endif
  NEED_DIRECT_GZIP_IMAGE=NO
  kimage := zImage
  target = $(kimage)
  kimagesrc = vmlinux.gz
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG = $(CONFDIR)/config.$(KPKG_SUBARCH)
  ifneq (,$(findstring $(KPKG_SUBARCH),mvme147 mvme16x bvme6000))
    loaderdep=vmelilo
    loader=vmelilo
    loaderdoc=VmeliloDefault
  else
    loaderdep=
    loader=lilo
    loaderdoc=
  endif
endif

### ARM
ifeq ($(strip $(architecture)),arm)
  GUESS_SUBARCH:='netwinder'

  ifneq (,$(findstring $(KPKG_SUBARCH),netwinder))
    KPKG_SUBARCH:=$(GUESS_SUBARCH)
    kimage := zImage
    target = Image
    kimagesrc = arch/$(KERNEL_ARCH)/boot/Image
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
    loaderdep=
    loader=nettrom
    loaderdoc=
    NEED_DIRECT_GZIP_IMAGE=NO
    DEBCONFIG= $(CONFDIR)/config.netwinder
  else
    kimage := zImage
    target = zImage
    NEED_DIRECT_GZIP_IMAGE=NO
    kimagesrc = arch/$(KERNEL_ARCH)/boot/zImage
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.arm
  endif
endif

### PowerPC
ifneq ($(strip $(filter ppc powerpc,$(architecture))),)
  ifeq ($(DEB_BUILD_ARCH),powerpc)
  # This is only meaningful when building on a PowerPC
    ifeq ($(GUESS_SUBARCH),)
      GUESS_SUBARCH:=$(shell awk '/machine/ { print $$3}' /proc/cpuinfo)
      ifneq (,$(findstring Power,$(GUESS_SUBARCH)))
        GUESS_SUBARCH:=pmac
      else
        ifneq (,$(findstring iMac,$(GUESS_SUBARCH)))
          GUESS_SUBARCH:=pmac
        endif
      endif
    else
      GUESS_SUBARCH:=pmac
    endif
  endif

  ifeq (,$(findstring $(KPKG_SUBARCH),apus prpmc chrp mbx pmac prep Amiga APUs CHRP MBX PReP chrp-rs6k ))
    KPKG_SUBARCH:=$(GUESS_SUBARCH)
  endif

  KERNEL_ARCH:=ppc

  ifneq (,$(findstring $(KPKG_SUBARCH),APUs apus Amiga))
    KPKG_SUBARCH:=apus
    loader := NoLoader
    kimage := vmapus.gz
    target = zImage
    kimagesrc = $(shell if [ -d arch/$(KERNEL_ARCH)/boot/images ]; then \
	echo arch/$(KERNEL_ARCH)/boot/images/vmapus.gz ; else \
	echo arch/$(KERNEL_ARCH)/boot/$(kimage) ; fi)
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.apus
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),chrp-rs6k))
    KPKG_SUBARCH:=chrp-rs6k
    loaderdep=quik
    loader=quik
    loaderdoc=QuikDefault
    kimage := zImage
    target = $(kimage)
    kimagesrc = $(shell if [ -d arch/$(KERNEL_ARCH)/chrpboot ]; then \
	echo arch/$(KERNEL_ARCH)/chrpboot/$(kimage) ; else \
	echo arch/$(KERNEL_ARCH)/boot/images/$(kimage).chrp-rs6k ; fi)
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.chrp
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),CHRP chrp))
    KPKG_SUBARCH:=chrp
    loaderdep=quik
    loader=quik
    loaderdoc=QuikDefault
    kimage := zImage
    target = $(kimage)
    kimagesrc = $(shell if [ -d arch/$(KERNEL_ARCH)/chrpboot ]; then \
         echo arch/$(KERNEL_ARCH)/chrpboot/$(kimage) ; else \
         echo arch/$(KERNEL_ARCH)/boot/images/$(kimage).chrp ; fi)
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.chrp
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),PRPMC prpmc))
    KPKG_SUBARCH:=prpmc
    loader := NoLoader
    kimage := zImage
    target = $(kimage)
    kimagesrc = arch/$(KERNEL_ARCH)/boot/images/zImage.pplus
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),MBX mbx))
    KPKG_SUBARCH:=mbx
    loader := NoLoader
    kimage := zImage
    target = $(kimage)
    kimagesrc = $(shell if [ -d arch/$(KERNEL_ARCH)/mbxboot ]; then \
	echo arch/$(KERNEL_ARCH)/mbxboot/$(kimage) ; else \
	echo arch/$(KERNEL_ARCH)/boot/images/zvmlinux.embedded; fi)
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.mbx
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),pmac))
    KPKG_SUBARCH:=pmac
    target := zImage
    ifeq ($(DEB_BUILD_ARCH),powerpc)
      # This is only meaningful when building on a PowerPC
      ifneq (,$(shell grep NewWorld /proc/cpuinfo))
        loaderdep=yaboot
        loader=yaboot
        #loaderdoc=
      else
        loaderdep=quik
        loader=quik
        loaderdoc=QuikDefault
      endif
    else
      loaderdep=yaboot
      loader=yaboot
    endif
    kimagesrc = vmlinux
    kimage := vmlinux
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
    HAVE_COFF_IMAGE = YES
    coffsrc = $(shell if [ -d arch/$(KERNEL_ARCH)/coffboot ]; then \
         echo arch/$(KERNEL_ARCH)/coffboot/$(kimage).coff ; else \
         echo arch/$(KERNEL_ARCH)/boot/images/$(kimage).coff ; fi)
    coffdest=$(INT_IMAGE_DESTDIR)/vmlinux.coff-$(version)
    DEBCONFIG = $(CONFDIR)/config.pmac
  endif

  ifneq (,$(findstring $(KPKG_SUBARCH),PReP prep))
    KPKG_SUBARCH:=prep
    loader := NoLoader
    kimage := zImage
    target = $(kimage)
    kimagesrc = $(shell if [ -d arch/$(KERNEL_ARCH)/boot/images ]; then \
         echo arch/$(KERNEL_ARCH)/boot/images/$(kimage).prep ; else \
         echo arch/$(KERNEL_ARCH)/boot/$(kimage) ; fi)
    kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
    DEBCONFIG = $(CONFDIR)/config.prep
  endif

endif


##### Alpha
ifeq ($(strip $(architecture)),alpha)
kimage := vmlinuz
loaderdep=
loader=milo
loaderdoc=
target = boot
kimagesrc = arch/$(KERNEL_ARCH)/boot/vmlinux.gz
kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
DEBCONFIG = $(CONFDIR)/config.alpha
endif


##### Sparc
ifeq ($(strip $(architecture)),sparc)
  kimage := vmlinuz
  loaderdep = silo
  loader = silo
  loaderdoc=SiloDefault
  NEED_DIRECT_GZIP_IMAGE = YES
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG = $(CONFDIR)/config.sparc
  ifeq (,$(APPEND_TO_VERSION))
    ARCH_IN_NAME = YES
  endif

  ifeq (,$(KPKG_SUBARCH))
    ifeq (sparc64,$(strip $(shell uname -m)))
      KPKG_SUBARCH = sparc64
    else
      KPKG_SUBARCH = sparc32
    endif
  endif

  ifneq (,$(filter sparc64%,$(KPKG_SUBARCH)))
     KERNEL_ARCH = sparc64
  else
     ifneq (,$(filter sparc%,$(KPKG_SUBARCH)))
        KERNEL_ARCH = sparc
     else
        KERNEL_ARCH = $(strip $(shell uname -m))
     endif
  endif

  ifneq ($(shell if [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 5 -a  \
                    $(SUBLEVEL) -ge 41 ]; then echo new; \
             elif [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 6 ]; then \
                                         echo new; \
             elif [ $(VERSION) -ge 3 ]; then echo new; fi),)
    target    = image
    kimagesrc = arch/$(KERNEL_ARCH)/boot/image
  else
    target    = vmlinux
    kimagesrc = vmlinux
  endif
endif

##### amd64
ifeq ($(strip $(architecture)),amd64)
  KERNEL_ARCH=x86_64
  kimage := bzImage
  loaderdep=lilo (>= 19.1) | grub
  loader=lilo
  loaderdoc=LiloDefault
  target = $(kimage)
  kimagesrc = $(strip arch/$(KERNEL_ARCH)/boot/$(kimage))
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG= $(CONFDIR)/config.$(KPKG_SUBARCH)
  kelfimagesrc = vmlinux
  kelfimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
endif


##### i386 and such
ifeq ($(strip $(architecture)),i386)
  # sub archs can be i386 i486 i586 i686
  GUESS_SUBARCH:=$(shell if test -f .config; then \
                        perl -nle '/^CONFIG_M(.86)=y/ && print "$$1"' .config;\
                       else \
                         uname -m;\
                       fi)
  ifeq (,$(findstring $(KPKG_SUBARCH),i386 i486 i586 i686))
    KPKG_SUBARCH:=$(GUESS_SUBARCH)
  endif
  kimage := bzImage
  loaderdep=lilo (>= 19.1) | grub
  loader=lilo
  loaderdoc=LiloDefault
  target = $(kimage)
  kimagesrc = $(strip arch/$(KERNEL_ARCH)/boot/$(kimage))
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG= $(CONFDIR)/config.$(KPKG_SUBARCH)
  kelfimagesrc = vmlinux
  kelfimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
endif

##### S/390
ifeq ($(strip $(architecture)),s390)
  # make it possible to build s390x kernels on s390 for 2.4 kernels only 
  # because 2.6 always use s390 as architecture. 
  ifeq (4,$(PATCHLEVEL))
    ifeq (,$(findstring $(KPKG_SUBARCH),s390 s390x))
      KPKG_SUBARCH = s390
    endif
    KERNEL_ARCH = $(KPKG_SUBARCH)
    ifneq ($(shell uname -m),$(KPKG_SUBARCH))
      UNAME_MACHINE = $(KPKG_SUBARCH)
      export UNAME_MACHINE
    endif
  endif
  kimage := zimage
  loaderdep=zipl
  loader=zipl
  loaderdoc=
  target = image
  NEED_DIRECT_GZIP_IMAGE=NO
  kimagesrc = $(strip arch/$(KERNEL_ARCH)/boot/$(target))
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG= $(CONFDIR)/config.$(KPKG_SUBARCH)
endif

##### hppa
ifeq ($(strip $(architecture)),hppa)
  kimage := vmlinux
  loaderdep=palo
  loader=palo
  loaderdoc=
  target=$(kimage)
  NEED_DIRECT_GZIP_IMAGE=NO
  # Override arch name because hppa uses arch/parisc not arch/hppa
  KERNEL_ARCH := parisc
  kimagesrc=$(kimage)
  kimagedest=$(INT_IMAGE_DESTDIR)/vmlinux-$(version)
  # This doesn't seem to work, but the other archs do it...
  DEBCONFIG=$(CONFDIR)/config.$(KPKG_SUBARCH)
endif

##### ia64
ifeq ($(strip $(architecture)),ia64)
  kimage := vmlinuz
  loaderdep=elilo
  loader=elilo
  loaderdoc=
  target=compressed
  NEED_DIRECT_GZIP_IMAGE=NO
  kimagesrc=vmlinux.gz
  kimagedest=$(INT_IMAGE_DESTDIR)/vmlinuz-$(version)
  DEBCONFIG=$(CONFDIR)/config.$(KPKG_SUBARCH)
endif

##### mips
ifeq ($(strip $(architecture)),mips)
  kimage := vmlinux
  loaderdep=arcboot
  loader=arcboot
  loaderdoc=
  NEED_DIRECT_GZIP_IMAGE=NO
  kimagesrc = $(strip vmlinux)
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
  DEBCONFIG= $(CONFDIR)/config.$(KPKG_SUBARCH)

  ifneq ($(shell if [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 5 -a  \
                      $(SUBLEVEL) -ge 41 ]; then echo new; \
               elif [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 6 ]; then \
                                           echo new; \
               elif [ $(VERSION) -ge 3 ]; then echo new; fi),)
    target    =
  else
    target    = boot
  endif

  ifneq (,$(filter mips64%,$(KPKG_SUBARCH)))
    KERNEL_ARCH = mips64
  endif
  ifneq (,$(filter %-64,$(KPKG_SUBARCH)))
    KERNEL_ARCH = mips64
  endif
endif

##### mipsel
ifeq ($(strip $(architecture)),mipsel)
  kimage := vmlinux
  loaderdep=delo
  loader=delo
  loaderdoc=
  NEED_DIRECT_GZIP_IMAGE=NO
  kimagesrc = $(strip vmlinux)
  kimagedest = $(INT_IMAGE_DESTDIR)/vmlinux-$(version)
  DEBCONFIG= $(CONFDIR)/config.$(KPKG_SUBARCH)
  KERNEL_ARCH= mips
  #HAVE_COFF_IMAGE = YES
  #coffsrc = $(strip arch/$(KERNEL_ARCH)/boot/vmlinux.ecoff)
  #coffdest=$(INT_IMAGE_DESTDIR)/vmlinux.ecoff-$(version)

  ifneq ($(shell if [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 5 -a  \
                      $(SUBLEVEL) -ge 41 ]; then echo new; \
               elif [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 6 ]; then \
                                           echo new; \
               elif [ $(VERSION) -ge 3 ]; then echo new; fi),)
    target    =
  else
    target    = boot
  endif

  ifneq (,$(filter mips64el%,$(KPKG_SUBARCH)))
    KERNEL_ARCH = mips64
  endif
  ifneq (,$(filter %-64,$(KPKG_SUBARCH)))
    KERNEL_ARCH = mips64
  endif
endif

ifeq ($(strip $(architecture)),um)
  kimage := linux
  target = linux
  loaderdep=
  loaderdoc=
endif
######################################################################
######################################################################

ifneq ($(strip $(loaderdep)),)
  int_loaderdep := $(loaderdep),
else
  int_loaderdep :=
endif



# The following variable is used to simplify the process of making
# diffs and orig targets, Please set it if AND ONLY IF no patches
# have been applied to the upstream source, in other words, we have
# just added debian* files.  If any patches were applied, please
# leave it empty

# NO_SRC_CHANGES =
NO_SRC_CHANGES = YES


# NOTE: FLAVOUR is now obsolete
# If you want to have more than one kernel configuration per kernel
# version, set FLAVOUR in the top level kernel Makefile *before*
# invoking make-kpkg -- it will be appended to UTS_RELEASE in
# version.h (separated by a hyphen). This affects everything -- the
# names and versions of the image, source, headers, and doc packages,
# and where the modules are searched for in /lib/modules.

ifdef FLAVOUR
# uhm - should check if we really have a Makefile capable of Flavours?
endif

FLAVOUR:=$(shell grep ^FLAVOUR Makefile 2>/dev/null | \
                  perl -ple 's/FLAVOUR[\s:=]+//g')

ifeq ($(strip $(FLAVOUR_SEP)),)
FLAVOUR_SEP:= +
endif

ifneq ($(strip $(FLAVOUR)),)
INT_FLAV := $(FLAVOUR_SEP)$(FLAVOUR)
FLAV_ARG := FLAVOUR=$(FLAVOUR)
else
INT_FLAV :=
FLAV_ARG :=
endif

## This is the replacement for FLAVOUR
EXTRAVERSION =$(strip $(EXTRA_VERSION))
ifneq ($(strip $(APPEND_TO_VERSION)),)
iatv := $(strip $(APPEND_TO_VERSION))
EXTRAV_ARG := EXTRAVERSION=${EXTRA_VERSION}${iatv}
else
iatv :=
EXTRAV_ARG :=
endif

UTS_RELEASE_VERSION=$(shell if [ -f include/linux/version.h ]; then                     \
                 grep 'define UTS_RELEASE' include/linux/version.h |                    \
                 perl -nle  'm/^\s*\#define\s+UTS_RELEASE\s+("?)(\S+)\1/g && print $$2;';\
                 else echo "" ;                                                         \
                 fi)
 
version = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)$(iatv)$(INT_FLAV)

# KPKG_SUBARCH is used to distinguish Amiga, Atari, Macintosh, etc. kernels
# for Debian/m68k.  INT_SUBARCH is used in the names of the image file
# produced. It only affects the naming of the kernel-image as the
# source and doc packages are architecture independent and the
# kernel-headers do not vary from one sub-architecture to the next.

# This is the default
INT_SUBARCH :=

ifneq ($(strip $(ARCH_IN_NAME)),)
ifneq ($(strip $(KPKG_SUBARCH)),)
INT_SUBARCH := -$(KPKG_SUBARCH)
endif
endif



# The name of the package (for example, `emacs').
package   := kernel-source-$(version)
h_package := kernel-headers-$(version)
i_package := kernel-image-$(version)$(INT_SUBARCH)
d_package := kernel-doc-$(version)
l_package := libc-kheaders

SOURCE_TOP:= debian/tmp-source
HEADER_TOP:= debian/tmp-headers
IMAGE_TOP := debian/tmp-image
DOC_TOP   := debian/tmp-doc

SOURCE_DOC:= $(SOURCE_TOP)/usr/share/doc/$(package)
HEADER_DOC:= $(HEADER_TOP)/usr/share/doc/$(h_package)
IMAGE_DOC := $(IMAGE_TOP)/usr/share/doc/$(i_package)
DOC_DOC   := $(DOC_TOP)/usr/share/doc/$(d_package)

SOURCE_SRC:= $(SOURCE_TOP)/usr/src/$(package)
HEADER_SRC:= $(HEADER_TOP)/usr/src/$(h_package)



FILES_TO_CLEAN  = modules/modversions.h modules/ksyms.ver debian/files \
                  conf.vars scripts/cramfs/cramfsck scripts/cramfs/mkcramfs \
                  applied_patches debian/buildinfo
STAMPS_TO_CLEAN = stamp-build stamp-configure stamp-source stamp-image \
                  stamp-headers stamp-src stamp-diff stamp-doc \
                  stamp-buildpackage stamp-libc-kheaders stamp-debian \
                  stamp-patch stamp-kernel-configure
DIRS_TO_CLEAN   = $(SOURCE_TOP) $(HEADER_TOP) $(IMAGE_TOP) $(DOC_TOP)

CONFLOC    :=$(shell if test -f ~/.kernel-pkg.conf; then\
                        echo ~/.kernel-pkg.conf; \
                     else \
                        echo /etc/kernel-pkg.conf; \
                     fi)
LIBLOC     :=/usr/share/kernel-package

ifeq ($(strip $(MODULE_LOC)),)
MODULE_LOC =/usr/src/modules
endif

DEBDIR      = $(LIBLOC)
DEBDIR_NAME = $(shell basename $(DEBDIR))

ifeq ($(strip $(VERSIONED_PATCH_DIR)),)
VERSIONED_PATCH_DIR         = $(shell if [ -d \
/usr/src/kernel-patches/$(architecture)/$(VERSION).$(PATCHLEVEL).$(SUBLEVEL) \
			       ]; then echo \
/usr/src/kernel-patches/$(architecture)/$(VERSION).$(PATCHLEVEL).$(SUBLEVEL); \
			    fi)
endif

ifeq ($(strip $(VERSIONED_ALL_PATCH_DIR)),)
VERSIONED_ALL_PATCH_DIR         = $(shell if [ -d \
/usr/src/kernel-patches/all/$(VERSION).$(PATCHLEVEL).$(SUBLEVEL) \
			       ]; then echo \
/usr/src/kernel-patches/all/$(VERSION).$(PATCHLEVEL).$(SUBLEVEL); \
			    fi)
endif

ifeq ($(strip $(PATCH_DIR)),)
PATCH_DIR  = $(shell if [ -d /usr/src/kernel-patches/$(architecture)/ ];\
                        then echo /usr/src/kernel-patches/$(architecture); \
	             fi)
endif

ifeq ($(strip $(ALL_PATCH_DIR)),)
ALL_PATCH_DIR  = $(shell if [ -d /usr/src/kernel-patches/all/ ]; \
                            then echo /usr/src/kernel-patches/all/ ;\
			 fi)
endif

VERSIONED_ALL_PATCH_APPLY   = $(VERSIONED_ALL_PATCH_DIR)/apply
VERSIONED_ALL_PATCH_UNPATCH = $(VERSIONED_ALL_PATCH_DIR)/unpatch

VERSIONED_DIR_PATCH_APPLY   = $(VERSIONED_PATCH_DIR)/apply
VERSIONED_DIR_PATCH_UNPATCH = $(VERSIONED_PATCH_DIR)/unpatch

ALL_PATCH_APPLY   = $(ALL_PATCH_DIR)/apply
ALL_PATCH_UNPATCH = $(ALL_PATCH_DIR)/unpatch

DIR_PATCH_APPLY   = $(PATCH_DIR)/apply
DIR_PATCH_UNPATCH = $(PATCH_DIR)/unpatch

# The destination of all .deb files
# (suggested by Rob Browning <osiris@cs.utexas.edu>)
DEB_DEST := ..
SRCTOP := $(shell if [ "$$PWD" != "" ]; then echo $$PWD; else pwd; fi)
INSTALL_MOD_PATH=$(SRCTOP)/$(IMAGE_TOP)
KPKG_DEST_DIR ?= $(SRCTOP)/..

install_file=    install -p    -o root -g root -m 644
install_program= install -p    -o root -g root -m 755
make_directory=  install -p -d -o root -g root -m 755
deb_rule = $(MAKE) -f $(DEBDIR)/rules

# Include any site specific overrides here.
-include $(CONFLOC)

# Over ride the config file from the environment/command line
ifneq ($(strip $(KPKG_MAINTAINER)),)
maintainer=$(KPKG_MAINTAINER)
endif

ifneq ($(strip $(KPKG_EMAIL)),)
email=$(KPKG_EMAIL)
endif

# This should be a  name to feed the modules build for pgp signature,
# since we the maintainer would be different there.
ifneq ($(strip $(PGP_SIGNATURE)),)
pgp=$(PGP_SIGNATURE)
endif

ifneq ($(strip $(EXTRA_DOCS)),)
extra_docs = $(EXTRA_DOCS)
endif

ifneq ($(strip $(extra_docs)),)
HAVE_EXTRA_DOCS:=$(shell if [ -e $(extra_docs) ]; then echo YES; fi)
endif

ifneq ($(strip $(DEBIAN_REVISION_MANDATORY)),)
debian_revision_mandatory:=$(DEBIAN_REVISION_MANDATORY)
endif
 

ifneq ($(strip $(install_vmlinux)),)
int_install_vmlinux:=$(install_vmlinux)
endif
 
ifneq ($(strip $(KPKG_FOLLOW_SYMLINKS_IN_SRC)),)
int_follow_symlinks_in_src=YES
else
ifneq ($(strip $(kpkg_follow_symlinks_in_src)),)
int_follow_symlinks_in_src=YES
endif
endif





# The Debian revision
ifneq ($(strip $(DEBIAN_REVISION)),)
HAS_CHANGELOG := $(shell \
    if test -f debian/changelog -a \( -f stamp-debian -o -f debian/official \);\
    then echo YES;\
    else echo NO; fi; )
else
HAS_CHANGELOG := $(shell if test -f debian/changelog; then echo YES;\
                          else echo NO; fi; )
endif
# If there is a changelog file, it overrides. The only exception is
# when there is no stamp-config, and there is no debian/official,
# *AND* there is a DEBIAN_REVISION, in which case the DEBIAN_REVISION
# over rides (since we are going to replace the changelog file soon
# anyway.  Else, use the commandline or env var setting. Or else
# default to 10.00.Custom, unless the human has requested that the
# revision is mandatory, in which case we raise an error

ifeq ($(strip $(HAS_CHANGELOG)),YES)
debian := $(shell if test -f debian/changelog; then \
                     perl -nle 'print /\((\S+)\)/; exit 0' debian/changelog;\
                  fi; )
else
ifneq ($(strip $(DEBIAN_REVISION)),)
debian := $(DEBIAN_REVISION)
else
ifeq ($(strip $(debian)),)
ifneq ($(strip $(debian_revision_mandatory)),)
$(error A Debian revision is mandatory, but none was provided)
else
debian := 10.00.Custom
endif
endif
endif
endif

# Hmm. The version that we have computed *MUST* match the one that is in the
# changelog.
ifeq ($(strip $(HAS_CHANGELOG)),YES)
saved_version := $(shell if test -f debian/changelog; then \
                     perl -nle 'print /^kernel-source-(\S+)/; exit 0' \
                          debian/changelog;\
                  fi; )
ifneq ($(strip $(saved_version)),)
ifneq ($(strip $(saved_version)),$(strip $(version)))
HAVE_VERSION_MISMATCH=YES
endif
endif
endif


ifneq ($(strip $(DELETE_BUILD_LINK)),)
delete_build_link := YES
else
ifeq ($(strip $(delete_build_link)),)
delete_build_link := $(shell if test -f debian/official; then echo YES;\
                          else echo NO; fi; )
endif
endif

ifneq ($(strip $(IMAGE_IN_BOOT)),)
link_in_boot := $(IMAGE_IN_BOOT)
endif

ifneq ($(strip $(LINK_IN_BOOT)),)
link_in_boot := $(LINK_IN_BOOT)
endif

ifneq ($(strip $(NO_SYMLINK)),)
no_symlink := $(NO_SYMLINK)
endif

ifneq ($(strip $(REVERSE_SYMLINK)),)
reverse_symlink := $(REVERSE_SYMLINK)
endif

ifneq ($(strip $(IMAGE_TYPE)),)
kimage = $(IMAGE_TYPE)
endif

ifneq ($(strip $(PATCH_THE_KERNEL)),)
patch_the_kernel = $(PATCH_THE_KERNEL)
endif

ifneq ($(strip $(KPKG_SELECTED_PATCHES)),)
ifeq ($(strip $(patch_the_kernel)),NO)
patch_the_kernel = NO
else
ifeq ($(strip $(patch_the_kernel)),no)
patch_the_kernel = NO
else
patch_the_kernel = YES
endif
endif
endif


ifeq ($(strip $(patch_the_kernel)),yes)
patch_the_kernel = YES
endif
ifeq ($(strip $(patch_the_kernel)),Yes)
patch_the_kernel = YES
endif
ifeq ($(strip $(patch_the_kernel)),YEs)
patch_the_kernel = YES
endif
ifeq ($(strip $(patch_the_kernel)),yEs)
patch_the_kernel = YES
endif
ifeq ($(strip $(patch_the_kernel)),yES)
patch_the_kernel = YES
endif
ifeq ($(strip $(patch_the_kernel)),yeS)
patch_the_kernel = YES
endif



ifneq ($(strip $(CONFIG_TARGET)),)
config_target := $(CONFIG_TARGET)
have_new_config_target := YES
endif

# If config_target doesn't end in `config' then reset it to `oldconfig'.
ifneq ($(patsubst %config,config,$(strip $(config_target))),config)
config_target := oldconfig
have_new_config_target :=
endif

ifneq ($(strip $(USE_SAVED_CONFIG)),)
use_saved_config = $(USE_SAVED_CONFIG)
endif

#ifeq ($(origin var),command line)
#$(warn You are setting an internal var from the cmdline. Use at your own risk)
#endif
#you can automated it a bit more with $(foreach) and $(if)

###ROOT_COMMAND
ifneq ($(strip $(ROOT_CMD)),)
int_root_cmd := -r$(strip $(ROOT_CMD))
else
# well, ROOT_CMD is not set yet
ifneq ($(strip $(root_cmd)),)

# Try and set ROOT_CMD from root_cmd
int_dummy_root := $(root_cmd)
ifneq ($(strip $(findstring -us, $(int_dummy_root))),)
int_dummy_root := $(subst -us,, $(strip $(int_dummy_root)))
endif
ifneq ($(strip $(findstring -uc, $(int_dummy_root))),)
int_dummy_root := $(subst -uc,, $(strip $(int_dummy_root)))
endif


ifneq ($(strip $(findstring -r, $(int_dummy_root))),)
ROOT_CMD := $(patsubst -r%, %, $(filter -r%, $(strip $(int_dummy_root))))
else
ROOT_CMD     := $(strip $(root_cmd))
endif


ifeq ($(strip $(findstring -r, $(root_cmd))),)
int_root_cmd := -r$(strip $(root_cmd))
else
int_root_cmd := $(root_cmd)
endif
endif
endif

ifneq ($(strip $(UNSIGN_SOURCE)),)
int_root_cmd := $(int_root_cmd) -us
endif

ifneq ($(strip $(UNSIGN_CHANGELOG)),)
int_root_cmd := $(int_root_cmd) -uc
endif

# make sure that root_cmd and int_root_cmd are the same
ifneq ($(strip $(int_root_cmd)),)
root_cmd := $(int_root_cmd)
endif

int_am_root  := $(shell [ $$(id -u) -eq 0 ] && echo "YES" )
int_get_root := $(shell [ $$(id -u) -ne 0 ] && echo "$(ROOT_CMD)" )


ifneq ($(strip $(CLEAN_SOURCE)),)
do_clean = $(CLEAN_SOURCE)
endif

ifneq ($(strip $(CONCURRENCY_LEVEL)),)
do_parallel = -j$(CONCURRENCY_LEVEL)

# Well, I wish there was something better than guessing by version number
CAN_DO_DEP_FAST=$(shell if   [ $(VERSION) -lt 2 ];    then echo '';  \
                        elif [ $(VERSION) -gt 2 ];    then echo YES; \
                        elif [ $(PATCHLEVEL) -lt 4 ]; then echo '';  \
                        else                             echo YES; \
                        fi)
ifneq ($(strip $(CAN_DO_DEP_FAST)),)
fast_dep= -j$(CONCURRENCY_LEVEL)
endif

endif

ifneq ($(strip $(SOURCE_CLEAN_HOOK)),)
source_clean_hook=$(SOURCE_CLEAN_HOOK)
endif
ifneq ($(strip $(HEADER_CLEAN_HOOK)),)
header_clean_hook=$(HEADER_CLEAN_HOOK)
endif
ifneq ($(strip $(DOC_CLEAN_HOOK)),)
doc_clean_hook=$(DOC_CLEAN_HOOK)
endif

ifneq ($(strip $(INITRD)),)
initrddep := initrd-tools (>= 0.1.48), # there is a space here
else
initrddep :=
endif

ifeq ($(strip $(CONFDIR)),)
ifeq ($(strip $(patch_the_kernel)),YES)
CONFDIR     = $(PATCH_DIR)
else
ifeq ($(strip $(patch_the_kernel)),yes)
CONFDIR     = $(PATCH_DIR)
else
CONFDIR     = $(DEBDIR)/Config
endif
endif
endif

# The file which has local configuration
CONFIG_FILE := $(shell if test -e .config ; then \
                           echo .config; \
                       elif test -e $(DEBCONFIG) ; then \
                           echo $(DEBCONFIG); \
                       elif test -e $(CONFDIR)/config ; then \
                           echo $(CONFDIR)/config ; \
                       elif test -e $(DEBDIR)/config ; then \
                           echo $(DEBDIR)/config ; \
                       elif test -e /boot/config-$(version) ; then \
                           echo /boot/config-$(version) ; \
                       elif test -e /boot/config-$$(uname -r) ; then \
                           echo /boot/config-$$(uname -r) ; \
                       else echo /dev/null ; \
                       fi)


# See if we are being run in the kernel directory
IN_KERNEL_DIR := $(shell if test -d drivers -a -d kernel -a -d fs -a                \
                                 -d include/linux ; then                            \
                            echo YES;                                               \
                         fi )

IN_KERNEL_HEADERS=$(shell if [ -f kernel-headers.revision ]; then                    \
                               cat kernel-headers.revision;                          \
                            else echo "" ;                                          \
                            fi)

ifeq ($(strip $(IN_KERNEL_DIR)),)
ifneq ($(strip $(IN_KERNEL_HEADERS)),)
version=$(UTS_RELEASE_VERSION)
debian=$(IN_KERNEL_HEADERS)
endif
endif


# Deal with modules issues

# define MODULES_ENABLED if appropriate
ifneq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
MODULES_ENABLED := YES
endif

# accept both space separated list of modules, as well as comma
# separated ones
comma:= ,
empty:=
space:= $(empty) $(empty)
valid_modules:=

# See what modules we are talking about
ifeq ($(strip $(MODULES_ENABLED)),YES)
ifneq ($(strip $(KPKG_SELECTED_MODULES)),)
canonical_modules=$(subst $(comma),$(space),$(KPKG_SELECTED_MODULES))
else
canonical_modules=$(shell test -e $(MODULE_LOC) && \
                       find $(MODULE_LOC) -follow -maxdepth 1 -type d -print |\
			   egrep -v '^$(MODULE_LOC)/$$')
endif


# Now, if we have any modules at all, they are in canonical_modules
ifneq ($(strip $(canonical_modules)),)

# modules can have the full path, or just the name of the module. We
# make all the modules ahve absolute paths by fleshing them out.
path_modules   :=$(filter     /%, $(canonical_modules))
no_path_modules:=$(filter-out /%, $(canonical_modules))
fleshed_out    :=$(foreach mod,$(no_path_modules),$(MODULE_LOC)/$(mod))

# Hmmph. recreate the canonical modules; now everything has a full
# path name.

canonical_modules:=$(path_modules) $(fleshed_out)
# test to see if the dir names are real
valid_modules = $(shell for dir in $(canonical_modules); do \
                            if [ -d $$dir ] && [ -x $$dir/debian/rules ]; then \
                               echo $$dir;                  \
                            fi;                             \
                        done)


endif
endif

ifeq ($(strip $(patch_the_kernel)),YES)

# Well then. Let us see if we want to select the patches we apply.
ifneq ($(strip $(KPKG_SELECTED_PATCHES)),)
canonical_patches=$(subst $(comma),$(space),$(KPKG_SELECTED_PATCHES))

ifneq ($(strip $(canonical_patches)),)
# test to see if the patches exist
temp_valid_patches = $(shell for name in $(canonical_patches); do             \
                            if [ -x $(VERSIONED_DIR_PATCH_APPLY)/$$name -a    \
                                 -x $(VERSIONED_DIR_PATCH_UNPATCH)/$$name ];  \
                               then echo $(VERSIONED_DIR_PATCH_APPLY)/$$name; \
                            elif [ -x $(VERSIONED_ALL_PATCH_APPLY)/$$name -a  \
                                   -x $(VERSIONED_ALL_PATCH_UNPATCH)/$$name ];\
                               then echo $(VERSIONED_ALL_PATCH_APPLY)/$$name; \
                            elif [ -x $(DIR_PATCH_APPLY)/$$name -a            \
                                 -x $(DIR_PATCH_UNPATCH)/$$name ]; then       \
                               echo $(DIR_PATCH_APPLY)/$$name;                \
                            elif [ -x $(ALL_PATCH_APPLY)/$$name -a            \
                                    -x $(ALL_PATCH_UNPATCH)/$$name ]; then    \
                               echo $(ALL_PATCH_APPLY)/$$name;                \
                            else                                              \
                               echo $$name.error;                             \
                            fi;                                               \
                        done)

temp_patch_not_found = $(filter %.error, $(temp_valid_patches))
patch_not_found = $(subst .error,,$(temp_patch_not_found))
ifneq ($(strip $(patch_not_found)),)
$(error Could not find patch for $(patch_not_found))
endif

valid_patches = $(filter-out %.error, $(temp_valid_patches))

ifeq ($(strip $(valid_patches)),)
$(error Could not find patch scripts for $(canonical_patches))
endif



canonical_unpatches = $(shell new="";                                         \
                              for name in $(canonical_patches); do            \
                                  new="$$name $$new";                         \
                              done;                                           \
                              echo $$new;)

temp_valid_unpatches = $(shell for name in $(canonical_unpatches); do         \
                            if [ -x $(VERSIONED_DIR_PATCH_APPLY)/$$name -a    \
                                 -x $(VERSIONED_DIR_PATCH_UNPATCH)/$$name ];  \
                              then echo $(VERSIONED_DIR_PATCH_UNPATCH)/$$name;\
                            elif [ -x $(VERSIONED_ALL_PATCH_APPLY)/$$name -a  \
                                   -x $(VERSIONED_ALL_PATCH_UNPATCH)/$$name ];\
                              then echo $(VERSIONED_ALL_PATCH_UNPATCH)/$$name;\
                            elif [ -x $(DIR_PATCH_APPLY)/$$name -a            \
                                 -x $(DIR_PATCH_UNPATCH)/$$name ]; then       \
                               echo $(DIR_PATCH_UNPATCH)/$$name;              \
                            elif [ -x $(ALL_PATCH_APPLY)/$$name -a            \
                                    -x $(ALL_PATCH_UNPATCH)/$$name ]; then    \
                               echo $(ALL_PATCH_UNPATCH)/$$name;              \
                            else                                              \
                               echo $$name.error;                             \
                            fi;                                               \
                        done)
temp_unpatch_not_found = $(filter %.error, $(temp_valid_unpatches))
unpatch_not_found = $(subst .error,,$(temp_unpatch_not_found))
ifneq ($(strip $(unpatch_not_found)),)
$(error Could not find unpatch for $(unpatch_not_found))
endif

valid_unpatches = $(filter-out %.error, $(temp_valid_unpatches))

ifeq ($(strip $(valid_unpatches)),)
$(error Could not find un-patch scripts for $(canonical_unpatches))
endif


endif
endif
endif

old_applied_patches=$(shell if [ -f applied_patches ]; then                   \
                               cat applied_patches;                           \
                            else                                              \
                               echo '';                                       \
                            fi )

ifeq ($(strip $(valid_unpatches)),)
ifneq ($(strip $(old_applied_patches)),) 
old_unpatches=$(shell new="";                                          \
                      for name in $(notdir $(old_applied_patches)); do \
                          new="$$name $$new";                          \
                      done;                                            \
                      echo $$new;)
temp_old_unpatches = $(shell for name in $(old_unpatches); do         \
                            if [ -x $(VERSIONED_DIR_PATCH_UNPATCH)/$$name ];  \
                              then echo $(VERSIONED_DIR_PATCH_UNPATCH)/$$name;\
                            elif [ -x $(VERSIONED_ALL_PATCH_UNPATCH)/$$name ];\
                              then echo $(VERSIONED_ALL_PATCH_UNPATCH)/$$name;\
                            elif [ -x $(DIR_PATCH_UNPATCH)/$$name ]; then     \
                               echo $(DIR_PATCH_UNPATCH)/$$name;              \
                            elif [ -x $(ALL_PATCH_UNPATCH)/$$name ]; then     \
                               echo $(ALL_PATCH_UNPATCH)/$$name;              \
                            else                                              \
                               echo $$name.error;                             \
                            fi;                                               \
                        done)
temp_old_unpatch_not_found = $(filter %.error, $(temp_old_unpatches))
old_unpatch_not_found = $(subst .error,,$(temp_unpatch_not_found))
valid_unpatches = $(filter-out %.error, $(temp_old_unpatches))
endif
endif

# See if the version numbers are valid
HAVE_VALID_PACKAGE_VERSION := $(shell \
      if test -x $(DEBDIR)/kpkg-vercheck; then \
	$(DEBDIR)/kpkg-vercheck $(debian) ; \
      else \
        echo "Could not find $(DEBDIR)/kpkg-vercheck" ; \
      fi )

TAR_COMPRESSION := $(shell \
      if tar --help | grep -- \-\-bzip2 >/dev/null; then  \
         echo --bzip2; \
      else \
         echo --gzip; \
      fi )
TAR_SUFFIX := $(shell \
      if tar --help | grep -- \-\-bzip2 >/dev/null; then  \
         echo bz2; \
      else \
         echo gz; \
      fi )

STOP_FOR_BIN86 = NO
CONTROL=$(DEBDIR)/Control
ifeq ($(strip $(architecture)),i386)
NEED_BIN86 := $(shell if dpkg --compare-versions \
                  $(VERSION).$(PATCHLEVEL) lt 2.4 >/dev/null 2>&1; \
                  then echo YES; fi)
ifeq ($(strip $(NEED_BIN86)),YES)
CONTROL=$(DEBDIR)/Control.bin86
HAVE_BIN86 := $(shell if test -x /usr/bin/as86; then echo YES; \
                      else echo NO; fi )
ifeq ($(strip $(HAVE_BIN86)),NO)
STOP_FOR_BIN86 = YES
endif
endif
endif

# Bug out if the version number id not all lowercase
lc_version = $(shell echo $(version) | tr A-Z a-z)
ifneq ($(strip $(version)),$(strip $(lc_version)))
$(error Error. The version number $(strip $(version)) is not all \
 lowercase. Since the version ends up in the package name of the \
 kernel image package, this is a Debian policy violation, and \
 the packaging system shall refuse to package the image. )
endif

ifeq (,$(strip $(kimagedest)))
$(error Error. I do not know where the kernel image goes to [kimagedest undefined]\
 The usual case for this is that I could not determine which arch or subarch \
 tihs machine belongs to. Please specify a subarch, and try again.)
endif
ifeq (,$(strip $(kimagesrc)))
$(error Error. I do not know where the kernel image goes to [kimagesrc undefined]\
 The usual case for this is that I could not determine which arch or subarch \
 tihs machine belongs to. Please specify a subarch, and try again.)
endif

# export variables
export root_cmd FLAVOUR INT_SUBARCH APPEND_TO_VERSION UNSIGN_CHANGELOG  \
       UNSIGN_SOURCE ROOT_CMD MODULE_LOC EXTRAVERSION ALL_PATCH_DIR     \
       ALL_PATCH_APPLY ALL_PATCH_UNPATCH DIR_PATCH_UNPATCH              \
       DIR_PATCH_APPLY VERSIONED_PATCH_DIR VERSIONED_ALL_PATCH_UNPATCH  \
       VERSIONED_ALL_PATCH_APPLY VERSIONED_DIR_PATCH_UNPATCH            \
       VERSIONED_DIR_PATCH_APPLY KPKG_SELECTED_PATCHES                  \
       KPKG_SELECTED_MODULES CONCURRENCY_LEVEL


ifeq ($(strip $(IN_KERNEL_DIR)),)
# Hah! Not in kernel directory!!
build configure clean binary kernel_source kernel-source kernel-headers\
stamp-source kernel_headers stamp-headers kernel_image stamp-image \
kernel-image kernel-doc kernel_doc stamp-doc buildpackage \
libc_kheaders libc-kheaders stamp-libc-kheaders kernel-image-deb debian:
	@echo "You should invoke this command from the top level directory of"
	@echo "a linux kernel source directory tree, and as far as I can tell,"
	@echo "the current directory:"
	@echo "	$(SRCTOP)"
	@echo "is not a top level linux kernel source directory. "
	@echo ""
	@echo "	(If I am wrong then kernel-packages and the linux kernel"
	@echo "	 are so out sync that you'd better get the latest versions"
	@echo "	 of the kernel-package package and the Linux sources)"
	@echo ""
	@echo "Please change directory to wherever linux kernel sources"
	@echo "reside and try again."
else
ifneq ($(strip $(HAVE_VALID_PACKAGE_VERSION)),YES)
# Hah! Bogus version number
build configure clean binary kernel_source kernel-source kernel-headers\
stamp-source kernel_headers stamp-headers kernel_image stamp-image \
kernel-image kernel-doc kernel_doc stamp-doc buildpackage kernel-image-deb \
debian:
	@echo "Problems ecountered with the version number $(debian)."
	@echo "$(HAVE_VALID_PACKAGE_VERSION)"
	@echo ""
	@echo "Please re-read the README file and try again."
else
ifeq ($(strip $(STOP_FOR__BIN86)),YES)
# Hah! we need bin 86, but it aint here
build configure clean binary kernel_source kernel-source kernel-headers\
stamp-source kernel_headers stamp-headers kernel_image stamp-image \
kernel-image kernel-doc kernel_doc stamp-doc buildpackage kernel-image-deb \
debian:
	@echo "You Need to install the package bin86 before you can "
	@echo "compile the kernel on this machine"
	@echo ""
	@echo "Please install bin86 and try again."
else
all build: debian configure stamp-build
stamp-build:
# Builds the binary package.
# debian.config contains the current idea of what the image should
# have.
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
ifneq ($(strip $(UTS_RELEASE_VERSION)), $(strip $(version)))
	if [ -f include/linux/version.h ]; then                                          \
             uts_ver=$$(grep 'define UTS_RELEASE' include/linux/version.h |                \
                perl -nle  'm/^\s*\#define\s+UTS_RELEASE\s+("?)(\S+)\1/g && print $$2;'); \
	    if [ "X$$uts_ver" != "X$(strip $(UTS_RELEASE_VERSION))" ]; then              \
                echo "The UTS Release version in include/linux/version.h";                \
	       echo "     \"$$uts_ver\" ";                                               \
                echo "does not match current version " ;                                  \
                echo "     \"$(strip $(version))\" " ;                                    \
                echo "Reconfiguring." ;                                                   \
                touch Makefile;                                                           \
             fi;                                                                          \
	fi
endif
	-test -f stamp-configure || $(deb_rule) configure
	$(MAKE) $(do_parallel) $(EXTRAV_ARG) $(FLAV_ARG) ARCH=$(KERNEL_ARCH) \
	                    $(CROSS_ARG) $(target)
ifneq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
	$(MAKE) $(do_parallel) $(EXTRAV_ARG) $(FLAV_ARG) ARCH=$(KERNEL_ARCH) \
	                    $(CROSS_ARG) modules
endif
	COLUMNS=150 dpkg -l 'gcc*' perl dpkg 'libc6*' binutils ldso make dpkg-dev |\
         awk '$$1 == "ii" { printf("%s-%s\n", $$2, $$3) }'   > debian/buildinfo
	@echo this was built on a machine with the kernel: >> debian/buildinfo
	uname -a >> debian/buildinfo
	echo using the compiler: >> debian/buildinfo
	grep LINUX_COMPILER include/linux/compile.h | \
           sed -e 's/.*LINUX_COMPILER "//' -e 's/"$$//' >> debian/buildinfo
	echo done >  $@

buildpackage: clean stamp-buildpackage
stamp-buildpackage: configure
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	test -f stamp-configure || $(deb_rule) configure
	echo 'Building Package' > stamp-building
ifneq ($(strip $(root_cmd)),)
	dpkg-buildpackage -nc $(strip $(root_cmd)) -m"$(maintainer) <$(email)>" -k"$(pgp)"
else
	dpkg-buildpackage -nc -m"$(maintainer) <$(email)>" -k"$(pgp)"
endif
	rm -f stamp-building
	echo done >  $@

# stamp-debian and stamp-configure used to be a single target. Now
# they are split - the reason is that arch-indep packages need to be
# built before arch-dep packages, and make-kpkg tries to do 'make
# config' for both cases.  This used to work because the .config file
# resided with kernel-source, but now that it is in kernel-patch, it
# breaks down.  I think the cleanest way out of this is to only deal
# with config files when necessary, and thus the split. Herbert Xu
debian: stamp-debian
stamp-debian:
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	@test -f $(DEBDIR)/rules || \
            echo Error: Could not find $(DEBDIR)/rules
	-test ! -f stamp-debian && test ! -f debian/official && \
	      rm -rf ./debian && mkdir ./debian
ifeq ($(strip $(patch_the_kernel)),YES)
	-test -f applied_patches && rm -f applied_patches
ifneq ($(strip $(valid_patches)),)
	-for patch in $(valid_patches) ; do            \
          if test -x  $$patch; then                    \
              if $$patch; then                         \
                  echo "Patch $$patch processed fine"; \
		  echo "$(notdir $$patch)" >> applied_patches;   \
              else                                     \
                   echo "Patch $(notdir $$patch)  failed.";      \
                   echo "Hit return to Continue";      \
		   read ans;                           \
              fi;                                      \
	  fi;                                          \
        done
	echo done >  stamp-patch
else
	if [ -n "$(VERSIONED_PATCH_DIR)" -a                   \
             -d $(VERSIONED_DIR_PATCH_APPLY) ]; then          \
            run-parts --exit-on-error $(VERSIONED_DIR_PATCH_APPLY); \
	    (cd $(VERSIONED_DIR_PATCH_APPLY); ls -1) >>       \
                                           applied_patches;   \
        echo done >  stamp-patch;                                    \
        else                                                  \
	    true;                                             \
	fi
	if [ -n "$(VERSIONED_ALL_PATCH_DIR)" -a               \
             -d $(VERSIONED_ALL_PATCH_APPLY)  ]; then         \
            run-parts --exit-on-error $(VERSIONED_ALL_PATCH_APPLY); \
	    (cd $(VERSIONED_ALL_PATCH_APPLY); ls -1) >>       \
                                           applied_patches;   \
        echo done >  stamp-patch;                                    \
        else                                                  \
	    true;                                             \
	fi
	if [ -n "$(PATCH_DIR)" -a                             \
             -d $(DIR_PATCH_APPLY) ]; then                    \
            run-parts --exit-on-error $(DIR_PATCH_APPLY);           \
	    (cd $(DIR_PATCH_APPLY); ls -1) >> applied_patches;\
        else                                                  \
	    true;                                             \
	fi
	if [ -n "$(ALL_PATCH_DIR)" -a                         \
             -d $(ALL_PATCH_APPLY)  ]; then                   \
            run-parts --exit-on-error $(ALL_PATCH_APPLY);           \
	    (cd $(ALL_PATCH_APPLY); ls -1) >> applied_patches;\
        echo done >  stamp-patch;                                    \
        else                                                  \
	    true;                                             \
	fi
endif
endif
	-test ! -f stamp-debian -a \
               ! \( -f debian/official -a -f debian/control \) &&         \
	   sed -e 's/=V/$(version)/g'        -e 's/=D/$(debian)/g'       \
	       -e 's/=A/$(architecture)/g'   -e 's/=SA/$(INT_SUBARCH)/g' \
                -e 's/=L/$(int_loaderdep) /g' -e 's/=I/$(initrddep)/g'    \
                -e 's/=CV/$(VERSION).$(PATCHLEVEL)/g'                     \
                -e 's/=M/$(maintainer) <$(email)>/g'                      \
		         $(CONTROL)> debian/control
	-test ! -f stamp-debian && test ! -f debian/official &&              \
	   sed -e 's/=V/$(version)/g' -e 's/=D/$(debian)/g'                  \
	    -e 's/=A/$(architecture)/g' -e 's/=M/$(maintainer) <$(email)>/g' \
		$(DEBDIR)/changelog > debian/changelog
	-test ! -f debian/rules &&                                       \
	   install -p -m 755 $(DEBDIR)/rules debian/rules
	echo done >  $@

# We could always do $(MAKE) -n -p dummy | grep ^CC >> .mak here if we cared
ifeq ($(strip $(INCLUDE_KERNEL_MAKEFILE)),yes)
include Makefile
conf_vars:
	@echo Please ignore the warning about overriding and ignoring targets above.
	@echo These are harmless. They are only invoked in a part of the process
	@echo that tries to snarf variable values for the conf.vars file.
	@echo "VERSION          = $(VERSION)"        > .mak
	@echo "PATCHLEVEL       = $(PATCHLEVEL)"    >> .mak
	@echo "SUBLEVEL 	      = $(SUBLEVEL)"      >> .mak
	@echo "EXTRAVERSION     = $(EXTRAVERSION)"  >> .mak
ifneq ($(strip $(iatv)),)
	@echo "APPEND_TO_VERSION = $(iatv)"          >> .mak
endif
ifeq ($(strip $(patch_the_kernel)),YES)
	@echo "KPKG_SELECTED_PATCHES = $(KPKG_SELECTED_PATCHES)" >> .mak
endif
ifeq ($(strip $(MODULES_ENABLED)),YES)
	@echo "KPKG_SELECTED_MODULES = $(KPKG_SELECTED_MODULES)" >> .mak
endif
	@echo "Debian Revision  = $(debian)"        >> .mak
	@echo "ARCH             = $(ARCH)"          >> .mak
	@echo "KPKG_ARCH        = $(KPKG_ARCH)"     >> .mak
	@echo "HOSTCC           = $(HOSTCC)"        >> .mak
	@echo "HOSTCFLAGS       = $(HOSTCFLAGS)"    >> .mak
	@echo "CROSS_COMPILE    = $(CROSS_COMPILE)" >> .mak
	@echo "AS               = $(AS)"            >> .mak
	@echo "LD               = $(LD)"            >> .mak
	@echo "CC               = $(CC)"            >> .mak
	@echo "CPP              = $(CPP)"           >> .mak
	@echo "AR               = $(AR)"            >> .mak
	@echo "NM               = $(NM)"            >> .mak
	@echo "STRIP            = $(STRIP)"         >> .mak
	@echo "OBJCOPY          = $(OBJCOPY)"       >> .mak
	@echo "OBJDUMP          = $(OBJDUMP)"       >> .mak
	@echo "MAKE             = $(MAKE)"          >> .mak
	@echo "GENKSYMS 	      = $(GENKSYMS)"      >> .mak
	@echo "CFLAGS           = $(CFLAGS)"        >> .mak
	@echo "AFLAGS           = $(AFLAGS)"        >> .mak
	@echo "MODFLAGS 	      = $(MODFLAGS)"      >> .mak
	@echo "do_parallel      = $(do_parallel)"   >> .mak
	@echo "fast_dep         = $(fast_dep)"      >> .mak
	@sed -e 's%$(TOPDIR)%$$(TOPDIR)%g' .mak     > conf.vars
	@rm -f .mak
else
conf.vars: Makefile
	$(MAKE) -f debian/rules INCLUDE_KERNEL_MAKEFILE=yes conf_vars
endif

dummy_do_dep:
	+$(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) $(CROSS_ARG) \
                                 ARCH=$(KERNEL_ARCH) $(fast_dep) dep 

stamp-kernel-configure: stamp-debian .config
	$(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) $(CROSS_ARG) \
                                 ARCH=$(KERNEL_ARCH) $(config_target) 	
ifeq ($(shell if [ $(VERSION) -ge 2 -a $(PATCHLEVEL) -ge 5 ]; then \
                  echo new;fi),)
	+$(MAKE) -f ./debian/rules dummy_do_dep
	$(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) $(CROSS_ARG) \
                                 ARCH=$(KERNEL_ARCH) clean 
else
	$(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) $(CROSS_ARG) \
                                ARCH=$(KERNEL_ARCH) prepare
endif
	echo done >  $@

configure: debian .config stamp-configure
stamp-configure: stamp-debian .config conf.vars stamp-kernel-configure
	echo done >  $@



.config:
ifneq ($(strip $(use_saved_config)),NO)
	test -f .config || test ! -f .config.save || \
		            cp -pf .config.save .config
endif
	test -f .config || test ! -f $(CONFIG_FILE) || \
		            cp -pf $(CONFIG_FILE) .config
	test -f .config || test ! -f $(DEBDIR)/config || \
		            cp -pf $(DEBDIR)/config  .config
ifeq ($(strip $(have_new_config_target)),)
	test -f .config || (echo "*** Need a config file .config" && false)
endif
# if $(have_new_config_target) is set, then we need not have a .config
# file at this point

clean:
ifeq ($(strip $(int_am_root)),)
ifeq ($(strip $(int_get_root)),)
	@echo "You may need root privileges - some parts may fail"
endif
	$(int_get_root) $(deb_rule) real_stamp_clean 
else
	$(deb_rule) real_stamp_clean 
endif

# Perhaps a list of patches should be dumped to a file on patching? so we
# only unpatch what we have applied? That would be changed, though saner,
# behaviour
real_stamp_clean:
	test ! -f .config || cp -pf .config config.precious
	-test -f Makefile && \
            $(MAKE) $(FLAV_ARG) $(EXTRAV_ARG) ARCH=$(KERNEL_ARCH) distclean
	test ! -f config.precious || mv -f config.precious .config
ifeq ($(strip $(patch_the_kernel)),YES)
	$(deb_rule) unpatch_now
endif
ifeq ($(strip $(NO_UNPATCH_BY_DEFAULT)),)
	test ! -f stamp-patch || $(deb_rule) unpatch_now
endif
	-test -f stamp-building || test -f debian/official || rm -rf debian
	rm -f $(FILES_TO_CLEAN) $(STAMPS_TO_CLEAN)
	rm -rf $(DIRS_TO_CLEAN)


unpatch_now:
ifneq ($(strip $(valid_unpatches)),)
	-for patch in $(valid_unpatches) ; do              \
          if test -x  $$patch; then                        \
              if $$patch; then                             \
                  echo "Removed Patch $$patch ";           \
              else                                         \
                   echo "Patch $$patch  failed.";          \
                   echo "Hit return to Continue";          \
		   read ans;                               \
              fi;                                          \
	  fi;                                              \
        done
	rm -f stamp-patch
else
	if [ -n "$(VERSIONED_PATCH_DIR)" -a                     \
             -d $(VERSIONED_DIR_PATCH_UNPATCH) ]; then          \
            run-parts --report $(VERSIONED_DIR_PATCH_UNPATCH); \
        else                                                    \
	    true;                                               \
	fi
	if [ -n "$(VERSIONED_ALL_PATCH_DIR)" -a                 \
             -d $(VERSIONED_ALL_PATCH_UNPATCH)  ]; then         \
            run-parts --report $(VERSIONED_ALL_PATCH_UNPATCH); \
        else                                                    \
	    true;                                               \
	fi
	if [ -n "$(PATCH_DIR)" -a                               \
             -d $(DIR_PATCH_UNPATCH) ]; then                    \
            run-parts --report $(DIR_PATCH_UNPATCH);           \
        else                                                    \
	    true;                                               \
	fi
	if [ -n "$(ALL_PATCH_DIR)" -a                           \
             -d $(ALL_PATCH_UNPATCH)  ]; then                   \
            run-parts --report $(ALL_PATCH_UNPATCH);           \
        else                                                    \
	    true;                                               \
	fi
	rm -f stamp-patch
endif


binary:       binary-indep binary-arch
binary-indep: kernel_source kernel_doc
binary-arch:  kernel_image  kernel_headers


kernel-source kernel_source: stamp-source
stamp-source: stamp-debian
ifeq ($(strip $(int_am_root)),)
ifeq ($(strip $(int_get_root)),)
	@echo need root privileges; exit 1
else
	$(int_get_root) $(deb_rule) real_stamp_source
endif
else
	$(deb_rule) real_stamp_source
endif

real_stamp_source:
ifeq ($(strip $(architecture)),um)
	echo done >  stamp-source
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	test -f stamp-debian || $(deb_rule) debian
	rm -rf $(SOURCE_TOP)
	$(make_directory) $(SOURCE_TOP)/DEBIAN
	$(make_directory) $(SOURCE_SRC)
	$(make_directory) $(SOURCE_DOC)
	sed -e 's/=P/$(package)/g' -e 's/=V/$(version)/g' \
	    $(DEBDIR)/src.postinst > $(SOURCE_TOP)/DEBIAN/postinst
	chmod 755 $(SOURCE_TOP)/DEBIAN/postinst
	$(install_file) debian/changelog               $(SOURCE_DOC)/changelog.Debian
	gzip -9qf                             	 $(SOURCE_DOC)/changelog.Debian
	$(install_file) $(DEBDIR)/README      	 $(SOURCE_DOC)/debian.README
	gzip -9qf                             	 $(SOURCE_DOC)/debian.README
	$(install_file) $(DEBDIR)/README.grub 	 $(SOURCE_DOC)/README.grub
	gzip -9qf                                $(SOURCE_DOC)/README.grub
	$(install_file) $(DEBDIR)/README.headers $(SOURCE_DOC)/README.headers
	gzip -9qf                                $(SOURCE_DOC)/README.headers
	$(install_file) $(DEBDIR)/README.tecra   $(SOURCE_DOC)/README.tecra
	gzip -9qf                                $(SOURCE_DOC)/README.tecra
	$(install_file) $(DEBDIR)/README.modules $(SOURCE_DOC)/README.modules
	gzip -9qf                                $(SOURCE_DOC)/README.modules
	$(install_file) $(DEBDIR)/sample.module.control \
                                            $(SOURCE_DOC)/sample.module.control
	gzip -9qf                           $(SOURCE_DOC)/sample.module.control
	$(install_file) README                     $(SOURCE_DOC)/README
	gzip -9qf                                  $(SOURCE_DOC)/README
	$(install_file) $(DEBDIR)/Flavours         $(SOURCE_DOC)/Flavours
	gzip -9qf                                  $(SOURCE_DOC)/Flavours
	$(install_file) $(DEBDIR)/Rationale        $(SOURCE_DOC)/Rationale
	gzip -9qf                                  $(SOURCE_DOC)/Rationale
	$(install_file) $(DEBDIR)/copyright.source $(SOURCE_DOC)/copyright
	echo "This was produced by kernel-package version $(kpkg_version)." > \
	         $(SOURCE_DOC)/Buildinfo
ifneq ($(strip $(int_follow_symlinks_in_src)),)
	-tar cfh - `echo * | sed -e 's/ debian//g' -e 's/\.deb//g' ` \
	| (cd $(SOURCE_SRC); umask 000; tar xpsf -)
	(cd $(SOURCE_SRC)/include; rm -rf asm ; )
else
	-tar cf - `echo * | sed -e 's/ debian//g' -e 's/\.deb//g' ` \
	| (cd $(SOURCE_SRC); umask 000; tar xspf -)
	(cd $(SOURCE_SRC)/include; rm -f asm ; )
endif
	$(install_file) debian/changelog         $(SOURCE_SRC)/Debian.src.changelog
	(cd $(SOURCE_SRC); \
            $(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) ARCH=$(KERNEL_ARCH) distclean)
	(cd $(SOURCE_SRC);         rm -f stamp-building $(STAMPS_TO_CLEAN))
	(cd $(SOURCE_SRC);         \
         [ ! -d scripts/cramfs ]   || make -C scripts/cramfs distclean ; )
	if test -f debian/official -a -f debian/README.Debian ; then \
           $(install_file) debian/README.Debian $(SOURCE_SRC)/README.Debian ; \
           $(install_file) debian/README.Debian $(SOURCE_DOC)/README.Debian ; \
	   gzip -9qf $(SOURCE_DOC)/README.Debian;\
	else \
	    sed -e 's/=V/$(version)/g' -e 's/=A/$(architecture)/g' \
                 $(DEBDIR)/README.source >  $(SOURCE_SRC)/README.Debian ; \
	fi
	if test -f README.Debian ; then \
           $(install_file) README.Debian $(SOURCE_DOC)/README.Debian.1st; \
	   gzip -9qf                     $(SOURCE_DOC)/README.Debian.1st;\
	fi
ifneq ($(strip $(source_clean_hook)),)
	(cd $(SOURCE_SRC);              \
               test -x $(source_clean_hook) && $(source_clean_hook))
endif
	chmod -R og=rX $(SOURCE_TOP)
	chown -R root:root $(SOURCE_TOP)
	(cd $(SOURCE_TOP)/usr/src/ && \
           tar $(TAR_COMPRESSION) -cf $(package).tar.$(TAR_SUFFIX) $(package) &&\
             rm -rf $(package);)
	dpkg-gencontrol -isp -p$(package) -P$(SOURCE_TOP)/
	chmod -R og=rX $(SOURCE_TOP)
	chown -R root:root $(SOURCE_TOP)
	dpkg --build $(SOURCE_TOP) $(DEB_DEST)
	rm -f -r $(SOURCE_TOP)
	echo done >  stamp-source
endif

libc-kheaders libc_kheaders: stamp-libc-kheaders
stamp-libc-kheaders: configure
	@echo This target is now obsolete.


kernel-headers kernel_headers: stamp-headers
stamp-headers: configure
ifeq ($(strip $(int_am_root)),)
ifeq ($(strip $(int_get_root)),)
	@echo need root privileges; exit 1
else
	$(int_get_root) $(deb_rule) real_stamp_headers
endif
else
	$(deb_rule) real_stamp_headers
endif

real_stamp_headers:
ifeq ($(strip $(architecture)),um)
	echo done >  stamp-headers
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
ifneq ($(strip $(UTS_RELEASE_VERSION)),$(strip $(version)))
	@echo "The UTS Release version in include/linux/version.h $(UTS_RELEASE_VERSION) does not match current version $(version), reconfiguring"
	touch Makefile
endif
	test -f stamp-configure || $(deb_rule) configure
	rm -rf $(HEADER_TOP)
	$(make_directory) $(HEADER_TOP)/DEBIAN
	$(make_directory) $(HEADER_SRC)
	$(make_directory) $(HEADER_DOC)
	sed -e 's/=P/$(h_package)/g' -e 's/=V/$(version)/g' \
		$(DEBDIR)/include.postinst > $(HEADER_TOP)/DEBIAN/postinst
	chmod 755 $(HEADER_TOP)/DEBIAN/postinst
	$(install_file) $(DEBDIR)/copyright.headers $(HEADER_DOC)/copyright
	$(install_file) debian/changelog         $(HEADER_DOC)/changelog.Debian
	gzip -9qf                                $(HEADER_DOC)/changelog.Debian
	$(install_file) $(DEBDIR)/README.headers $(HEADER_DOC)/debian.README
	gzip -9qf                                $(HEADER_DOC)/debian.README
	$(install_file) .config  	              $(HEADER_DOC)/config-$(version)
	$(install_file) conf.vars  	     $(HEADER_DOC)/conf.vars
	gzip -9qf                                $(HEADER_DOC)/config-$(version)
	gzip -9qf                                $(HEADER_DOC)/conf.vars
	$(install_file) CREDITS                  $(HEADER_DOC)/     
	gzip -9qf                                $(HEADER_DOC)/CREDITS
	$(install_file) MAINTAINERS              $(HEADER_DOC)/     
	gzip -9qf                                $(HEADER_DOC)/MAINTAINERS
	$(install_file) REPORTING-BUGS           $(HEADER_DOC)/     
	gzip -9qf                                $(HEADER_DOC)/REPORTING-BUGS
	$(install_file) README                   $(HEADER_DOC)/     
	gzip -9qf                                $(HEADER_DOC)/README
	if test -f debian/official -a -f debian/README.Debian ; then \
           $(install_file) debian/README.Debian $(HEADER_DOC)/README.Debian ; \
           gzip -9qf                            $(HEADER_DOC)/README.Debian ; \
           $(install_file) README.Debian $(HEADER_DOC)/README.Debian;\
	   gzip -9qf                     $(HEADER_DOC)/README.Debian;\
	fi
	if test -f README.Debian ; then \
           $(install_file) README.Debian $(HEADER_DOC)/README.Debian.1st;\
	     gzip -9qf                   $(HEADER_DOC)/README.Debian.1st;\
	fi
	echo "This was produced by kernel-package version $(kpkg_version)." > \
	         $(HEADER_DOC)/Buildinfo
	chmod 0644 $(HEADER_DOC)/Buildinfo
	$(install_file) Makefile       $(HEADER_SRC)
ifneq ($(strip $(int_follow_symlinks_in_src)),)
	-tar cfh - include |        (cd $(HEADER_SRC); umask 000; tar xsf -)
	(cd $(HEADER_SRC)/include; rm -rf asm; ln -s asm-$(KERNEL_ARCH) asm)
else
	-tar cf - include |        (cd $(HEADER_SRC); umask 000; tar xsf -)
	(cd $(HEADER_SRC)/include; rm -f asm; ln -s asm-$(KERNEL_ARCH) asm)
endif
	$(install_file) .config  	        $(HEADER_SRC)/.config
	echo $(debian)                    > $(HEADER_SRC)/kernel-headers.revision
ifneq ($(strip $(header_clean_hook)),)
	(cd $(HEADER_SRC);              \
               test -x $(header_clean_hook) && $(header_clean_hook))
endif
	dpkg-gencontrol -DArchitecture=$(architecture) -isp \
                        -p$(h_package) -P$(HEADER_TOP)/
	chown -R root:root $(HEADER_TOP)
	chmod -R og=rX $(HEADER_TOP)
	dpkg --build $(HEADER_TOP) $(DEB_DEST)
	rm -rf $(HEADER_TOP)
	echo done >  stamp-headers
endif

kernel-doc kernel_doc: stamp-doc
stamp-doc: stamp-debian
ifeq ($(strip $(int_am_root)),)
ifeq ($(strip $(int_get_root)),)
	@echo need root privileges; exit 1
else
	$(int_get_root) $(deb_rule) real_stamp_doc
endif
else
	$(deb_rule) real_stamp_doc
endif

real_stamp_doc:
ifeq ($(strip $(architecture)),um)
	echo done >  stamp-doc
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	test -f stamp-debian || $(deb_rule) debian
	rm -rf            $(DOC_TOP)
	$(make_directory) $(DOC_TOP)/DEBIAN
	$(make_directory) $(DOC_DOC)
	$(install_file) debian/changelog          $(DOC_DOC)/changelog.Debian
	$(install_file) $(DEBDIR)/README.doc      $(DOC_DOC)/README.Debian
	echo "This was produced by kernel-package version $(kpkg_version)." > \
	           $(DOC_DOC)/Buildinfo
	chmod 0644 $(DOC_DOC)/Buildinfo
	if test -f debian/official -a -f debian/README.Debian ; then \
           $(install_file) debian/README.Debian $(DOC_DOC)/README.Debian;\
	fi
	if test -f README.Debian ; then \
           $(install_file) README.Debian $(DOC_DOC)/README.Debian.1st;\
	fi
ifneq ($(strip $(shell if [ -x /usr/bin/db2html ]; then echo YSE; fi)),)
	$(MAKE)  mandocs htmldocs
endif
	-tar cf - Documentation | (cd $(DOC_DOC); umask 000; tar xsf -)
ifneq ($(strip $(doc_clean_hook)),)
	(cd $(DOC_DOC);              \
               test -x $(doc_clean_hook) && $(doc_clean_hook))
endif
	-gzip -9qfr $(DOC_DOC)
	-find $(DOC_DOC) -type f -name \*.gz -perm +111 -exec gunzip {} \;
	$(install_file) $(DEBDIR)/copyright.doc $(DOC_DOC)/copyright
	sed -e 's/=P/$(d_package)/g' -e 's/=V/$(version)/g' \
		$(DEBDIR)/src.postinst > $(DOC_TOP)/DEBIAN/postinst
	chmod 755 $(DOC_TOP)/DEBIAN/postinst
	dpkg-gencontrol -isp -p$(d_package) -P$(DOC_TOP)/
	chmod -R og=rX $(DOC_TOP)
	chown -R root:root $(DOC_TOP)
	dpkg --build $(DOC_TOP) $(DEB_DEST)
	rm -rf $(DOC_TOP)
	echo done >  stamp-doc
endif

kernel-image kernel_image: stamp-image
stamp-image: configure build kernel-image-deb
# % make config
# % make-kpkg build
# % sudo make -f debian/rules kernel-image-deb
# seems to create a working .deb with a kernel that gives the correct
# user name (as opposed to root@...)
kernel-image-deb:
ifeq ($(strip $(int_am_root)),)
ifeq ($(strip $(int_get_root)),)
	@echo need root privileges; exit 1
else
	$(int_get_root) $(deb_rule) real_stamp_image
endif
else
	$(deb_rule) real_stamp_image
endif

real_stamp_image:
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
ifneq ($(strip $(UTS_RELEASE_VERSION)),$(strip $(version)))
	@echo "The UTS Release version in include/linux/version.h $(UTS_RELEASE_VERSION) does not match current version $(version), reconfiguring."
	touch Makefile
endif
	rm -f -r ./$(IMAGE_TOP) ./$(IMAGE_TOP).deb
	test -f stamp-configure     || $(deb_rule) configure
	test -f stamp-build         || $(deb_rule) build
	$(make_directory) $(IMAGE_TOP)/DEBIAN
	$(make_directory) $(IMAGE_TOP)/$(IMAGEDIR)
	$(make_directory) $(IMAGE_DOC)
	sed -e 's/=V/$(version)/g'    -e 's/=B/$(link_in_boot)/g'   \
            -e 's/=S/$(no_symlink)/g' -e 's/=R/$(reverse_symlink)/g' \
            -e 's/=K/$(kimage)/g'     -e 's/=L/$(loader)/g'          \
            -e 's/=I/$(INITRD)/g'     -e 's,=D,$(IMAGEDIR),g'        \
            -e 's@=M@$(MKIMAGE)@g'    -e 's/=OF/$(AM_OFFICIAL)/g'    \
            -e 's@=A@$(DEB_HOST_ARCH)@g'                             \
             $(DEBDIR)/image.postinst > $(IMAGE_TOP)/DEBIAN/postinst
	chmod 755 $(IMAGE_TOP)/DEBIAN/postinst
	sed -e 's/=V/$(version)/g'    -e 's/=B/$(link_in_boot)/g'   \
            -e 's/=S/$(no_symlink)/g' -e 's/=R/$(reverse_symlink)/g' \
            -e 's/=K/$(kimage)/g'     -e 's/=L/$(loader)/g'          \
            -e 's/=I/$(INITRD)/g'     -e 's,=D,$(IMAGEDIR),g'        \
            -e 's@=M@$(MKIMAGE)@g'    -e 's/=OF/$(AM_OFFICIAL)/g'    \
             $(DEBDIR)/image.postrm > $(IMAGE_TOP)/DEBIAN/postrm
	chmod 755 $(IMAGE_TOP)/DEBIAN/postrm
	sed -e 's/=V/$(version)/g'    -e 's/=L/$(loader)/g'          \
	    -e 's/=I/$(INITRD)/g'     -e 's/=OF/$(AM_OFFICIAL)/g'    \
             -e 's@=M@$(MKIMAGE)@g'    -e 's@=A@$(DEB_HOST_ARCH)@g'   \
	             $(DEBDIR)/image.preinst > $(IMAGE_TOP)/DEBIAN/preinst
	chmod 755 $(IMAGE_TOP)/DEBIAN/preinst
	sed -e 's/=V/$(version)/g'    -e 's/=L/$(loader)/g'          \
             -e 's@=M@$(MKIMAGE)@g'    -e 's/=OF/$(AM_OFFICIAL)/g'    \
	             $(DEBDIR)/image.prerm > $(IMAGE_TOP)/DEBIAN/prerm
	chmod 755 $(IMAGE_TOP)/DEBIAN/prerm
	$(install_file) Documentation/Changes $(IMAGE_DOC)/
	gzip -9qf $(IMAGE_DOC)/Changes
	$(install_file) debian/changelog        $(IMAGE_DOC)/changelog.Debian
	gzip -9qf                               $(IMAGE_DOC)/changelog.Debian
ifdef loaderdoc
	$(install_file) $(DEBDIR)/$(loaderdoc)  $(IMAGE_DOC)/$(loaderdoc)
	gzip -9qf                               $(IMAGE_DOC)/$(loaderdoc)
endif
	$(install_file) $(DEBDIR)/README.image  $(IMAGE_DOC)/debian.README
	gzip -9qf                               $(IMAGE_DOC)/debian.README
	$(install_file) $(DEBDIR)/copyright.image $(IMAGE_DOC)/copyright
	echo "This was produced by kernel-package version $(kpkg_version)." > \
	           $(IMAGE_DOC)/Buildinfo
	chmod 0644 $(IMAGE_DOC)/Buildinfo
	$(install_file) .config          $(INT_IMAGE_DESTDIR)/config-$(version)
	$(install_file) conf.vars        $(IMAGE_DOC)/conf.vars
	gzip -9qf                        $(IMAGE_DOC)/conf.vars
	$(install_file) debian/buildinfo $(IMAGE_DOC)/buildinfo
	gzip -9qf                        $(IMAGE_DOC)/buildinfo
	if test -f debian/official -a -f debian/README.Debian ; then \
           $(install_file) debian/README.Debian  $(IMAGE_DOC)/README.Debian ; \
         gzip -9qf                               $(IMAGE_DOC)/README.Debian;\
	fi
	if test -f README.Debian ; then \
           $(install_file) README.Debian $(IMAGE_DOC)/README.Debian.1st;\
           gzip -9qf                     $(IMAGE_DOC)/README.Debian.1st;\
	fi
	if test -f Debian.src.changelog; then \
	  $(install_file) Debian.src.changelog  $(IMAGE_DOC)/; \
           gzip -9qf                             $(IMAGE_DOC)/Debian.src.changelog;\
	fi
ifeq ($(strip $(HAVE_EXTRA_DOCS)),YES)
	$(install_file) $(extra_docs) 	         $(IMAGE_DOC)/
endif
ifneq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
ifeq  ($(strip $(HAVE_NEW_MODLIB)),)
	$(mod_inst_cmds)
else
# could have also said DEPMOD=/bin/true instead of moving files
ifneq ($(strip $(KERNEL_CROSS)),)
	mv System.map System.precious
endif
	$(MAKE) $(EXTRAV_ARG) INSTALL_MOD_PATH=$(INSTALL_MOD_PATH)           \
                $(CROSS_ARG) ARCH=$(KERNEL_ARCH) modules_install
ifneq ($(strip $(KERNEL_CROSS)),)
	mv System.precious System.map
endif
endif
	-depmod -q -FSystem.map -b $(IMAGE_TOP) $(version)
endif
	if test -d $(SRCTOP)/debian/image.d ; then                            \
             IMAGE_TOP=$(IMAGE_TOP) version=$(version)                        \
                   run-parts --verbose $(SRCTOP)/debian/image.d ;             \
        fi
	if [ -x debian/post-install ]; then                                   \
		IMAGE_TOP=$(IMAGE_TOP) version=$(version) debian/post-install;\
	fi
ifeq ($(strip $(NEED_DIRECT_GZIP_IMAGE)),YES)
	gzip -9vc $(kimagesrc) > $(kimagedest)
else
	cp $(kimagesrc) $(kimagedest)
endif
	chmod 644 $(kimagedest)
ifeq ($(strip $(HAVE_COFF_IMAGE)),YES)
	cp $(coffsrc)   $(coffdest)
	chmod 644       $(coffdest)
endif
ifeq ($(strip $(int_install_vmlinux)),YES)
ifneq ($(strip $(kelfimagesrc)),)
	cp $(kelfimagesrc) $(kelfimagedest)
	chmod 644 $(kelfimagedest)
endif
endif
	test ! -s applied_patches || cp applied_patches                        \
                        $(INT_IMAGE_DESTDIR)/patches-$(version)
	test ! -s applied_patches || chmod 644                                 \
                        $(INT_IMAGE_DESTDIR)/patches-$(version)
	test ! -f System.map ||  cp System.map                                 \
                        $(INT_IMAGE_DESTDIR)/System.map-$(version)
	test ! -f System.map ||  chmod 644                                     \
                        $(INT_IMAGE_DESTDIR)/System.map-$(version)
	# For LKCD enabled kernels
	test ! -f Kerntypes ||  cp Kerntypes                                   \
                        $(INT_IMAGE_DESTDIR)/Kerntypes-$(version)
	test ! -f Kerntypes ||  chmod 644                                      \
                        $(INT_IMAGE_DESTDIR)/Kerntypes-$(version)
ifeq ($(strip $(delete_build_link)),YES)
	rm -f $(IMAGE_TOP)/lib/modules/$(version)/build
endif
	dpkg-gencontrol -DArchitecture=$(architecture) -isp                   \
                        -p$(i_package) -P$(IMAGE_TOP)/
	chmod -R og=rX $(IMAGE_TOP)
	chown -R root:root $(IMAGE_TOP)
	dpkg --build $(IMAGE_TOP) $(DEB_DEST)
	rm -f -r $(IMAGE_TOP)
ifeq ($(strip $(do_clean)),YES)
	$(MAKE) $(EXTRAV_ARG) $(FLAV_ARG) ARCH=$(KERNEL_ARCH) \
                                clean
	rm -f stamp-build
endif
	echo done >  stamp-image

# This for STOP_FOR_BIN86
endif

# This endif is for HAVE_VALID_PACKAGE_VERSION
endif

#This  endif is for IN_KERNEL_DIR
endif


# only generate module image packages
modules-image modules_image: configure 
ifeq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
	@echo Modules not configured, so not making $@
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	-for module in $(valid_modules) ; do                       \
          if test -d  $$module; then                                \
	    (cd $$module;                                          \
              if ./debian/rules KVERS="$(version)" KSRC="$(SRCTOP)" \
                             KMAINT="$(pgp)" KEMAIL="$(email)"      \
                             KPKG_DEST_DIR="$(KPKG_DEST_DIR)"       \
                             KPKG_MAINTAINER="$(maintainer)"        \
                             KPKG_EXTRAV_ARG="$(EXTRAV_ARG)"        \
                             KDREV="$(debian)" kdist_image; then    \
                  echo "Module $$module processed fine";            \
              else                                                  \
                   echo "Module $$module failed.";                  \
                   if [ "X$(strip $(root_cmd))" != "X" ]; then      \
                      echo "Perhaps $$module does not understand --rootcmd?";  \
                      echo "If you see messages that indicate that it is not"; \
                      echo "in fact being built as root, please file a bug ";  \
                      echo "against $$module.";                     \
                   fi;                                              \
                   echo "Hit return to Continue";                   \
		 read ans;                                        \
              fi;                                                   \
	     );                                                    \
	  fi;                                                      \
        done
endif

# generate the modules packages and sign them
modules: configure 
ifeq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
	@echo Modules not configured, so not making $@
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	-for module in $(valid_modules) ; do                       \
          if test -d  $$module; then                                \
	    (cd $$module;                                          \
              if ./debian/rules KVERS="$(version)" KSRC="$(SRCTOP)" \
                             KMAINT="$(pgp)" KEMAIL="$(email)"      \
                             KPKG_DEST_DIR="$(KPKG_DEST_DIR)"       \
                             KPKG_MAINTAINER="$(maintainer)"        \
                             ARCH=$(KERNEL_ARCH)                    \
                             KPKG_EXTRAV_ARG="$(EXTRAV_ARG)"        \
                             KDREV="$(debian)" kdist; then          \
                  echo "Module $$module processed fine";            \
              else                                                  \
                   echo "Module $$module failed.";                  \
                   if [ "X$(strip $(root_cmd))" != "X" ]; then      \
                      echo "Perhaps $$module does not understand --rootcmd?";  \
                      echo "If you see messages that indicate that it is not"; \
                      echo "in fact being built as root, please file a bug ";  \
                      echo "against $$module.";                     \
                   fi;                                              \
                   echo "Hit return to Continue?";                  \
		 read ans;                                        \
              fi;                                                   \
	     );                                                    \
	  fi;                                                      \
        done
endif

# configure the modules packages
modules-config modules_config: configure
ifeq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
	@echo Modules not configured, so not making $@
else
ifneq ($(strip $(HAVE_VERSION_MISMATCH)),)
	@(echo "The changelog says we are creating $(saved_version), but I thought the version is $(version)"; exit 1)
endif
	-for module in $(valid_modules) ; do                       \
          if test -d  $$module; then                                \
	    (cd $$module;                                          \
              if ./debian/rules KVERS="$(version)" KSRC="$(SRCTOP)" \
                             KMAINT="$(pgp)" KEMAIL="$(email)"      \
                             KPKG_DEST_DIR="$(KPKG_DEST_DIR)"       \
                             KPKG_MAINTAINER="$(maintainer)"        \
                             ARCH=$(KERNEL_ARCH)                    \
                             KPKG_EXTRAV_ARG="$(EXTRAV_ARG)"        \
                             KDREV="$(debian)" kdist_configure; then\
                  echo "Module $$module configured fine";           \
              else                                                  \
                   echo "Module $$module failed to configure";      \
                   echo "Hit return to Continue?";                  \
		 read ans;                                        \
              fi;                                                   \
	     );                                                    \
	  fi;                                                      \
        done
endif

modules-clean modules_clean: .config
ifeq ($(strip $(shell egrep ^[^\#]*CONFIG_MODULES $(CONFIG_FILE))),)
	@echo Modules not configured, so not making $@
else
	-for module in $(MODULE_LOC)/* ; do \
          if test -d  $$module; then \
	    (cd $$module; \
              if ./debian/rules KVERS="$(version)" KSRC="$(SRCTOP)" \
                             KMAINT="$(pgp)" KEMAIL="$(email)"      \
                             KPKG_DEST_DIR="$(KPKG_DEST_DIR)"       \
                             KPKG_MAINTAINER="$(maintainer)"        \
                             ARCH=$(KERNEL_ARCH)                    \
                             KPKG_EXTRAV_ARG="$(EXTRAV_ARG)"        \
                             KDREV="$(debian)" kdist_clean; then    \
                  echo "Module $$module cleaned";                   \
              else                                                  \
                   echo "Module $$module failed to clean up";       \
                   echo "Hit return to Continue?";                  \
		 read ans;                                        \
              fi;                                                   \
	     );                                                    \
	  fi;                                                      \
        done
endif


source diff:
	@echo >&2 'source and diff are obsolete - use dpkg-source -b'; false

define mod_inst_cmds
        @(                                                           \
        MODLIB=$(INSTALL_MOD_PATH)/lib/modules/$(version);           \
        cd modules;                                                  \
        MODULES="";                                                  \
        inst_mod() { These="`cat $$1`"; MODULES="$$MODULES $$These"; \
                mkdir -p $$MODLIB/$$2; cp $$These $$MODLIB/$$2;               \
                echo Installing modules under $$MODLIB/$$2; \
        }; \
                                                                               \
	if [ -f BLOCK_MODULES    ]; then inst_mod BLOCK_MODULES    block; fi; \
	if [ -f NET_MODULES      ]; then inst_mod NET_MODULES      net;   fi; \
	if [ -f IPV4_MODULES     ]; then inst_mod IPV4_MODULES     ipv4;  fi; \
	if [ -f IPV6_MODULES     ]; then inst_mod IPV6_MODULES     ipv6;  fi; \
         if [ -f ATM_MODULES      ]; then inst_mod ATM_MODULES      atm;   fi; \
	if [ -f SCSI_MODULES     ]; then inst_mod SCSI_MODULES     scsi;  fi; \
	if [ -f FS_MODULES       ]; then inst_mod FS_MODULES       fs;    fi; \
	if [ -f NLS_MODULES      ]; then inst_mod NLS_MODULES      fs;    fi;        \
	if [ -f CDROM_MODULES    ]; then inst_mod CDROM_MODULES    cdrom; fi;        \
	if [ -f HAM_MODULES      ]; then inst_mod HAM_MODULES      net;   fi;        \
	if [ -f SOUND_MODULES    ]; then inst_mod SOUND_MODULES    sound; fi;        \
	if [ -f VIDEO_MODULES    ]; then inst_mod VIDEO_MODULES    video; fi;        \
	if [ -f FC4_MODULES      ]; then inst_mod FC4_MODULES      fc4;   fi;        \
	if [ -f IRDA_MODULES     ]; then inst_mod IRDA_MODULES     net;   fi;        \
         if [ -f USB_MODULES      ]; then inst_mod USB_MODULES      usb;   fi;        \
         if [ -f SK98LIN_MODULES  ]; then inst_mod SK98LIN_MODULES  net;   fi;        \
         if [ -f SKFP_MODULES     ]; then inst_mod SKFP_MODULES     net;   fi;        \
         if [ -f IEEE1394_MODULES ]; then inst_mod IEEE1394_MODULES ieee1394; fi;     \
         if [ -f PCMCIA_MODULES   ]; then inst_mod PCMCIA_MODULES pcmcia;   fi;       \
         if [ -f PCMCIA_NET_MODULES ]; then inst_mod PCMCIA_NET_MODULES pcmcia; fi;   \
         if [ -f PCMCIA_CHAR_MODULES ]; then inst_mod PCMCIA_CHAR_MODULES pcmcia; fi; \
         if [ -f PCMCIA_SCSI_MODULES ]; then inst_mod PCMCIA_SCSI_MODULES pcmcia; fi; \
                                                                                      \
        for f in *.o; do [ -r $$f ] && echo $$f; done > .allmods; \
        echo $$MODULES | tr ' ' '\n' | sort | comm -23 .allmods - > .misc; \
        if [ -s .misc ]; then inst_mod .misc misc; fi; \
        rm -f .misc .allmods; \
        )
endef

# 		2.0.38	2.2.12	2.3.1
# BLOCK_MODULES	X	X	X
# NET_MODULES	X	X	X
# IPV4_MODULES	X	X	X
# IPV6_MODULES		X	X
# ATM_MODULES			X
# SCSI_MODULES	X	X	X
# FS_MODULES	X	X	X
# NLS_MODULES		X	X
# CDROM_MODULES	X	X	X
# HAM_MODULES		X	X
# SOUND_MODULES		X	X
# VIDEO_MODULES		X	X
# FC4_MODULES		X	X
# IRDA_MODULES		X	X
# USB_MODULES			X

.PHONY: binary binary-arch binary-indep clean debian modules modules_image
