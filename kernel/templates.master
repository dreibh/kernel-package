Template: shared/kernel-image/preinst/initrd-=V
Type: Note
Description: Installing a kernel with an initrd image
 You are attempting to install an initrd kernel image (version
 ${version}) on a machine currently running kernel version
 ${hostversion}.
 .
 I have been unable to find a suitable tool for generating initrd images
 (I looked at the list "${ramdisk}")
 This will break the installation, unless such tools are also being installed
 right now in the same run. (This means, one from the following list
 ${initrddep})

Template: shared/kernel-image/preinst/bootloader-initrd-=V
Type: Boolean
Default: True
Description: Abort if boot loader is not yet configured for an initrd kernel
 You are attempting to install an initrd kernel image (version ${version})
 This will not work unless you have configured your boot loader to use
 initrd. (An initrd image is a kernel image that expects to use an INITial
 Ram Disk to mount a minimal root file system into RAM and use that for
 booting).
 .
 I repeat, You need to configure your boot loader -- please read your
 bootloader documentation for details on how to add initrd images.
 .
 If you have already done so, and you wish to get rid of this message,
 please put
  "do_initrd = Yes"
 in /etc/kernel-img.conf. Note that this is optional, but if you do not,
 you will continue to see this message whenever you install a kernel
 image using initrd.

Template: shared/kernel-image/preinst/lilo-initrd-=V
Type: Boolean
Default: True
Description: Abort if lilo is not yet configured for an initrd kernel
 You are attempting to install an initrd kernel image (version ${version})
 This will not work unless you have configured your boot loader to use
 initrd. (An initrd image is a kernel image that expects to use an INITial
 Ram Disk to mount a minimal root file system into RAM and use that for
 booting).
 .
 As a reminder, in order to configure LILO, you need to add an 
 'initrd=/initrd.img' to the image=/vmlinuz stanza of your /etc/lilo.conf
 .
 I repeat, You need to configure your boot loader -- please read your
 bootloader documentation for details on how to add initrd images.
 .
 If you have already done so, and you wish to get rid of this message,
 please put
  "do_initrd = Yes"
 in /etc/kernel-img.conf. Note that this is optional, but if you do not,
 you will continue to see this message whenever you install a kernel
 image using initrd.

Template: shared/kernel-image/preinst/elilo-initrd-=V
Type: Boolean
Default: True
Description: Abort if elilo is not yet configured for an initrd kernel
 You are attempting to install an initrd kernel image (version ${version})
 This will not work unless you have configured your boot loader to use
 initrd. (An initrd image is a kernel image that expects to use an INITial
 Ram Disk to mount a minimal root file system into RAM and use that for
 booting).
 .
 As a reminder, in order to configure ELILO, you need to add an 
 'initrd=/initrd.img' to the image=/vmlinuz stanza of your /etc/elilo.conf
 .
 I repeat, You need to configure your boot loader -- please read your
 bootloader documentation for details on how to add initrd images.
 .
 If you have already done so, and you wish to get rid of this message,
 please put
  "do_initrd = Yes"
 in /etc/kernel-img.conf. Note that this is optional, but if you do not,
 you will continue to see this message whenever you install a kernel
 image using initrd.

Template: shared/kernel-image/preinst/lilo-has-ramdisk
Type: Note
Description: Lilo has a ramdisk line, which should be commented or removed
 I have found a line
 ${LINE}
 in /etc/lilo.conf that should be removed or commented out, since you are using 
 initrd/initramfs.

Template: shared/kernel-image/preinst/failed-to-move-modules-=V
Type: Note
Description: Failed to move modules out of the way, aborting
 You are attempting to install a kernel image (version ${version})
 However, the directory ${modules_base}/${version} still exists.
 .
 As you have instructed, an attempt was made to move the directory out
 of the way. Unfortunately, There was a problem moving
 ${modules_base}/${version} to ${modules_base}/${dest}.
 .
 I suggest you move $modules_base/$version out of the way manually,
 and then try re-installing this image.
 .
 I am aborting.

Template: shared/kernel-image/preinst/overwriting-modules-=V
Type: Boolean
Default: True
Description: Stop install since the kernel-image is already installed?
 You are attempting to install a kernel image (version ${version})
 However, the directory $modules_base/$version still exists.  If this
 directory belongs to a previous ${package} package, and if
 you have deselected some modules, or installed standalone modules
 packages, this could be bad. However, if this directory exists because
 you are also installing some stand alone modules right now, and they
 got unpacked before I did, then this is pretty benign.  Unfortunately,
 I can not tell the difference.
 .
 If ${modules_base}/${version} belongs to a old install of
 ${package}, then this is your last chance to abort the
 installation of this kernel image (nothing has been changed yet).
 .
 If this directory is because of stand alone modules being installed
 right now, or if it does belong to an older ${package}
 package but you know what you are doing, and if you feel that this
 image should be installed despite this anomaly, Please answer n to the
 question.
 .
 Otherwise, I suggest you move ${modules_base}/${version} out of the way,
 perhaps to ${modules_base}/${version}.old or something, and then try
 re-installing this image.

Template: shared/kernel-image/preinst/already-running-this-=V
Type: Note
Description: The kernel version running is the same as the one being installed
 You are attempting to install a kernel version that is the same as
 the version you are currently running (version $running). The modules
 list is quite likely to have been changed, and the modules dependency
 file $modules_base/$version/modules.dep needs to be re-built. It can
 not be built correctly right now, since the module list for the
 running kernel are likely to be different from the kernel installed.
 I am creating a new modules.dep file, but that may not be
 correct. It shall be regenerated correctly at next reboot.
 .
 I repeat: you have to reboot in order for the modules file to be
 created correctly. Until you reboot, it may be impossible to load
 some modules. Reboot as soon as this install is finished (Do not
 reboot right now, since you may not be able to boot back up until
 installation is over, but boot immediately after). I can not stress
 that too much. You need to reboot soon.

Template: shared/kernel-image/postinst/create-kimage-link
Type: Boolean
Default: True
Desciption: Create a symbolic link to the current kernel image
 I notice that you do not have ${kimage} symbolic link. I can create one 
 for you, and it shall be updated by newer kernel image packages. This is
 useful if you use a boot loader like lilo.

Template: shared/kernel-image/postinst/kimage-is-a-directory
Type: Note
Description: Image symbolic link destination is a directory
 ${kimage} is a directory, which I did not expect.  I am trying to create a
 symbolic link with that name linked to ${image_dest}. Since a directory
 exists here, my assumptions are way off, and I am aborting.

----------------------------------------------------------------------

    print "There was a problem running depmod.  This may be benign, \n";
    print "(You may have versioned symbol names, for instance).\n";
    print "Or this could be an error.\n";
    print "\tdepmod exited with return value $exit_value\n";
    print "\tdepmod got a signal $signal_num \n" if $signal_num ;
    print "\tdepmod dumped core \n" if $dumped_core ;
    if ($initrd) {
      print "Since this image uses initrd, I am not deleting the file\n";
      print "$modules_base/$version/modules.dep. However, there is no\n";
      print "guarantee that the file is valid. I would strongly advice\n";
      print "you to either abort and fix the errors in depmod, or \n";
      print "regenerate the initrd image with a known good modules.dep\n";
      print "file. I repeat, an initrd kernel image with a bad modules.dep\n";
      print "shall fail to boot.\n";
    } else {
      print "In any case, since depmod is run at install time, \n";
      print "we could just defer running depmod\n";
    }

    if (! $ignore_depmod_err) {
      if (&ask( "Would you like to abort now")) {
        exit (1);
      } else {
        print STFERR "Ok, continuing as directed\n";
      }



    print STDERR <<"EOIMG";

I note that you have an old initrd symbolic link in place. The name of
the symbolic link is being changed to initrd.img I have two options
here.  I can: (A) delete the old symbolic link (default).  You shall
need to update the boot loader (b) Ignore it and do nothing

EOIMG
    ;
    my $answer='';
    print "Please select one of a, or b: ";
    $answer=<STDIN>;
    $answer =~ s/^\s+//;
    $answer =~ s/\s+$//;
    if ($answer =~ /^\s*a/i) {
      unlink "initrd";
    } else {
      print STDERR
        "Please note that initrd points to the wrong image now\n";
    }
  }


    print STDERR <<"EOIMG";
I note that you have an old $image_dir/initrd symbolic link in place.
The location of the symbolic link is now the same location as the kernel
image symbolic links, names, in $image_dest.  I have two options here.
I can:
 (A) delete the old symbolic link (default).  You shall need to update the
      boot loader
 (b) Ignore it and do nothing
EOIMG
    ;
    my $answer='';
    print "Please select one of a, or b: ";
    $answer=<STDIN>;
    if ($answer =~ /^\s*a/i) {
      unlink "$image_dir/initrd";
    } else {
      print STDERR
        "Please note that $image_dir/initrd points to the wrong image now\n";
    }
  }


  print STDERR <<"EOMAP";
 I notice that you have System.map symbolic links in /. These were
 installed by older kernel image packages. However, all the programs
 that look at the information in the map files (including top, ps, and
 klogd) also will look at /boot/System.map-<version>, we just need to
 ensure that that file is present, and no longer require the symbolic
 link.

 Actually, having the symbolic link in / is technically detrimental
 (apart from cluttering up /); many programs, though looking in /boot,
 still allow /System.map to override. If you use $Loader to choose
 between multiple kernels, then the /System.map symbolic link only
 applies to one such kernel, for all other choices the symbols loaded
 will be wrong. Not having the symbolic links at all prevents this.

 I can delete these symbolic links for you, if you wish.
EOMAP
  ;
  if ( &ask_y("Would you like to delete the obsolete links now" ) ) {
    unlink '/System.map' if -e '/System.map';
    unlink '/System.old' if -e '/System.old';
    print STFERR "Obsolete links removed.\n";
  } else {
    print STFERR
      "Ok, not deleting the files. Please remember to remove them manually.\n";
  }


  print STDERR << "MSGEND";
I have determined no bootloader is required for your architecure.  This is
either because there is no boot loader for your architecture, or because I
did not change anything that would cause the boot loader to be run.  However,
I could be wrong, and, if that is the case, I would appreciate it if you would
please report a bug against the kernel-package package.

Done.
MSGEND
  ;
  exit (0);

  print "Could not find where the current root file system is mounted!\n";
  print "Please make some arrangements for your system to boot the new\n";
  print "kernel (like running LILO, loadlin, SILO, QUIK, VMELILO, or  \n";
  print "getting a boot floppy).                                      \n";
  print "Please hit return to continue.                               \n";
  $answer = <STDIN>;
  exit (0);







print "A new kernel image has been installed, and usually that means  \n";
print "that some action has to be taken to make sure that the new     \n";
print "kernel image is used next time the machine boots. Usually,     \n";
print "this entails running a ``bootloader'' like SILO, loadlin, LILO,\n";
print "ELILO, QUIK, VMELILO, ZIPL, or booting from a floppy.   (Some  \n";
print "boot loader, like grub, for example, do not need to be run on  \n";
print "each new image install, so please ignore this if you are using \n";
print "such a boot loader).\n\n";

  print "Hmm. $Loader";
  printf " (LInux LOader)"                     if $loader =~ /^lilo/i;
  printf " (Efi LInux LOader)"                 if $loader =~ /^elilo/i;
  printf " (Sparc Improved Linux lOader)"      if $loader =~ /^silo/i;
  printf " (QUIK: PowerMac Boot Loader)"       if $loader =~ /^quik/i;
  printf " (yaboot: PowerMac Boot Loader)"     if $loader =~ /^yaboot/i;
  printf " (PALO: PA-RISC Boot Loader)"        if $loader =~ /^palo/i;
  printf " (VMELILO: m68k VME Boot Loader)"    if $loader =~ /^vmelilo/i;
  printf " (ZIPL: s390 & zSeries Boot Loader)" if $loader =~ /^zipl/i;
  printf " (ARCBOOT: MIPS SGI IP22  Boot Loader)" if $loader =~ /^arcboot/i;
  printf ", which is the boot loader I    \n";
  print "have additional help for, is not installed (it is, after all,\n";
  print "just one of many options). I am assuming you have made some  \n";
  print "other arrangements for your system to boot the new kernel.   \n";
  print "Please hit return to continue.                               \n";
  my $answer = <STDIN>;
  exit (0) unless defined $rootdevice;






  print STDERR <<"EOMSGC";

WARNING
If you are keeping another operating system or another version
of Linux on a separate disk partition, you should not have $Loader
install a boot block now. Wait until you read the $Loader documentation.
That is because installing a boot block now might make the other
system un-bootable. If you only want to run this version of Linux,
go ahead and install the boot block here. If it does not work, you
can still boot this system from $install_boot_method.

EOMSGC
  ;



  if (&ask("Would you like to create a boot floppy now")) {







if (-T "/etc/$loader.conf") {
  # Trust and use the existing lilo.conf.
  print "You already have a $Loader configuration in /etc/$loader.conf\n";
  if ($silent_loader) {
    my $ret = &run_lilo();
    exit $ret;
  } elsif ( &ask_y("Install a boot block using the existing /etc/$loader.conf"))
 {
    my $ret = &run_lilo();
    exit $ret;
  } elsif ($loader =~ /^elilo/io) {
    print "I don't know how to create an elilo.conf file from scratch,\n";
    print "sorry.  elilo can do that for you, if you invoke it with the\n";
    print "correct options.  Aborting.\n";
    exit(0);
  } else {
    if (&ask("Wipe out your old $Loader configuration and make a new one")) {
      my $ret = system("savelog /etc/$loader.conf");
      if ($ret) {
        print "There was a problem saving a copy of your /etc/$loader.conf\n";
        print "Since this could have grave repercussions, I am aborting.\n";
        exit(0);
      }
    } else {
      exit (0);
    }
  }
} elsif ($loader =~ /^elilo/io) {
  print "I don't know how to create an elilo.conf file from scratch,\n";
  print "sorry.  elilo can do that for you, if you invoke it with the\n";
  print "correct options.  Aborting.\n";
  exit(0);
}

if (! &ask_y("Do you wish to set up Linux to boot from the hard disk")) {
  exit (0);
}

if ($loader =~ /^lilo/io) {
  print <<EOF;

You must do three things to make the Linux system boot from the hard
disk. Install a partition boot record, install a master boot record,
and set the partition active. You will be asked to perform each of
these tasks. You may skip any or all of them, and perform them
manually later on
EOF
  ;

}
if ($loader =~ /^lilo/io) {
  print "\n";
  print "A master boot record is required to run the partition boot record.\n";
  if (-f "/boot/mbr.b") {
    print "If you are already using a boot manager, and want to keep it,\n";
    print "answer \"no\" to the following question. If you don't know\n";
    print "what a boot manager is or whether you have one, answer \"yes\".\n";
    if ( &ask_y("Install a master boot record (/boot/mbr.b) on $rootdisk")) {
      my $ret = system("dd if=/boot/mbr.b of=$rootdisk bs=444 count=1");
      if ($ret) {
        print "There was a problem copying the master boot record.\n";
        print "Please run \"dd if=/boot/mbr.b of=$rootdisk bs=444 count=1\"\n";
        print "by hand. Please hit return to continue.\n";
        my $ans = <STDIN>;
      }
    }
  } else {
    print "However, you do not have /boot/mbr.b, a common location of a \n";
    print "backup copy of the mbr.  I hope that your master boot record or \n";
    print "boot manager does boot the active partition.  If not, you have\n";
    print "to acquire the package mbr and install it. Please hit return to\n";
    print "proceed.\n";
    my $ans = <STDIN>;
  }
  print "\n";
  print "The master boot record will boot the active partition.\n";
  print "If you want your system to boot another operating system,\n";
  print "such as DOS or Windows, by default, answer \"no\" to the following\n";
  print "question. You may still use your boot manager or the master\n";
  print "boot record to boot Linux. If you want the system to boot Linux.\n";
  print "by default, answer \"yes\".\n";
  if ( &ask_y("Make $rootdevice the active partition") ) {
    my $ret = system("/sbin/activate $rootdisk $rootpartition");
    if ($ret) {
      print "There was an error trying to activate $rootdevice.\n";
      print "Please run \"/sbin/activate $rootdisk $rootpartition\"\n";
      print "by hand. Please hit return to proceed.\n";
      my $ans = <STDIN>;
    }
  } else {
    print "\n";
    print "OK. If you installed the master boot record, and the partition\n";
    print "boot record, you may boot Linux by holding down the shift key\n";
    print "as the system boots, and then pressing the $rootpartition key\n";
    print "when you see the \"1234F:\" prompt.\n";
    print "";
    print "For more information, see /usr/share/doc/mbr/README, and the files\n"
;
    print "in the /usr/share/doc/$loader directory.\n";
  }
} else {
  if (-f "/boot/old.b") {
    print "$loader has overwritten the original boot loader and saved it under\n
";
    print "/boot/old.b.  You can boot your old system (if any) using the\n";
    print "oldsys label at the $loader prompt.\n";
  }
}

















