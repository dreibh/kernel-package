#! /usr/bin/perl
#                              -*- Mode: Perl -*-
# debian.postinst ---
# Author           : Manoj Srivastava ( srivasta@pilgrim.umass.edu )
# Created On       : Sat Apr 27 05:55:26 1996
# Created On Node  : melkor.pilgrim.umass.edu
# Last Modified By : Manoj Srivastava
# Last Modified On : Sun Jan  6 03:33:58 2002
# Last Machine Used: glaurung.green-gryphon.com
# Update Count     : 231
# Status           : Unknown, Use with caution!
# HISTORY          :
# Description      :
#
#    $Id: image.postinst,v 1.93 2002/01/24 17:11:34 srivasta Exp $
#

#
#use strict; #for debugging

$|=1;

# Predefined values:
my $version         = "=V";
my $image_in_boot   = "=B";	# Should be empty, mostly
my $no_symlink      = "=S";	# Should be empty, mostly
my $reverse_symlink = "=R";	# Should be empty, mostly
my $do_symlink      = "Yes";	# target machine defined
my $do_boot_enable  = "Yes";	# target machine defined
my $do_bootfloppy   = "Yes";	# target machine defined
my $do_bootloader   = "Yes";	# target machine defined
my $move_image      = '';       # target machine defined
my $kimage          = "=K";	# Should be empty, mostly
my $loader          = "=L";     # lilo, silo, quik, palo, vmelilo, or nettrom
my $image_dir       = "=D";     # where the image is located
my $clobber_modules = '';       # target machine defined
my $relative_links  = "";       # target machine defined
my $initrd          = "=I";     # initrd kernel
my $do_initrd       = '';	# Normally we do not
my $use_hard_links  = '';       # hardlinks do not work across fs boundaries
my $postinst_hook   = '';       #Normally we do not
my $postrm_hook     = '';       #Normally we do not

my $package_name    = "kernel-image-$version";

my $Loader          = "NoLOADER"; #
$Loader             = "LILO"     if $loader =~ /^lilo/io;
$Loader             = "SILO"     if $loader =~ /^silo/io;
$Loader             = "QUIK"     if $loader =~ /^quik/io;
$Loader             = "yaboot"   if $loader =~ /^yaboot/io;
$Loader             = "PALO"     if $loader =~ /^palo/io;
$Loader             = "NETTROM"  if $loader =~ /^nettrom/io;
$Loader             = "VMELILO"  if $loader =~ /^vmelilo/io;
$Loader             = "ZIPL"     if $loader =~ /^zipl/io;
$Loader             = "ELILO"    if $loader =~ /^elilo/io;

# This should not point to /tmp, because of security risks.
my $temp_file_name = "/var/log/$loader" . "_log.$$";

#known variables
my @boilerplate     = ();
my @silotemplate    = ();
my @quiktemplate    = ();
my @palotemplate    = ();
my @vmelilotemplate = ();
my @zipltemplate    = ();
my $bootdevice      = '';
my $rootdevice      = '';
my $rootdisk        = '';
my $rootpartition   = '';
my $image_dest      = "/";
my $realimageloc    = "/$image_dir/";
my $have_conffile   = "";
my $silent_modules  = '';
my $silent_loader   = '';
my $minimal_swap    = '';       # Do not swap symlinks

my $CONF_LOC        = '/etc/kernel-img.conf';

# Ignore all invocations except when called on to configure.
exit 0 unless $ARGV[0] =~ /configure/;

# Do some preliminary sanity checks here to ensure we actually have an
# valid image dir
chdir('/')           or die "could not chdir to /:$!\n";
die "Internal Error: ($image_dir) is not a directory!\n"
  unless -d $image_dir;

# remove multiple leading slashes; make sure there is at least one.
$realimageloc  =~ s|^/*|/|o;
$realimageloc  =~ s|/+|/|o;
die "Internal Error: ($realimageloc) is not a directory!\n"
  unless -d $realimageloc;

if (-r "$CONF_LOC" && -f "$CONF_LOC"  ) {
  if (open(CONF, "$CONF_LOC")) {
    while (<CONF>) {
      chomp;
      s/\#.*$//g;
      next if /^\s*$/;

      $do_symlink      = "" if /do_symlinks\s*=\s*(no|false|0)\s*$/ig;
      $no_symlink      = "" if /no_symlinks\s*=\s*(no|false|0)\s*$/ig;
      $reverse_symlink = "" if /reverse_symlink\s*=\s*(no|false|0)\s*$/ig;
      $image_in_boot   = "" if /image_in_boot\s*=\s*(no|false|0)\s*$/ig;
      $move_image      = "" if /move_image\s*=\s*(no|false|0)\s*$/ig;
      $clobber_modules = '' if /clobber_modules\s*=\s*(no|false|0)\s*$/ig;
      $do_boot_enable  = '' if /do_boot_enable\s*=\s*(no|false|0)\s*$/ig;
      $do_bootfloppy   = '' if /do_bootfloppy\s*=\s*(no|false|0)\s*$/ig;
      $relative_links  = '' if /relative_links \s*=\s*(no|false|0)\s*$/ig;
      $do_bootloader   = '' if /do_bootloader\s*=\s*(no|false|0)\s*$/ig;
      $do_initrd       = '' if /do_initrd\s*=\s*(no|false|0)\s*$/ig;
      $use_hard_links  = '' if /use_hard_links\s*=\s*(no|false|0)\s*$/ig;
      $silent_modules  = '' if /silent_modules\s*=\s*(no|false|0)\s*$/ig;
      $silent_loader   = '' if /silent_loader\s*=\s*(no|false|0)\s*$/ig;
      $minimal_swap    = '' if /minimal_swap\s*=\s*(no|false|0)\s*$/ig;

      $do_symlink      = "Yes" if /do_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $no_symlink      = "Yes" if /no_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $reverse_symlink = "Yes" if /reverse_symlinks\s*=\s*(yes|true|1)\s*$/ig;
      $image_in_boot   = "Yes" if /image_in_boot\s*=\s*(yes|true|1)\s*$/ig;
      $move_image      = "Yes" if /move_image\s*=\s*(yes|true|1)\s*$/ig;
      $clobber_modules = "Yes" if /clobber_modules\s*=\s*(yes|true|1)\s*$/ig;
      $do_boot_enable  = "Yes" if /do_boot_enable\s*=\s*(yes|true|1)\s*$/ig;
      $do_bootfloppy   = "Yes" if /do_bootfloppy\s*=\s*(yes|true|1)\s*$/ig;
      $do_bootloader   = "Yes" if /do_bootloader\s*=\s*(yes|true|1)\s*$/ig;
      $relative_links  = "Yes" if /relative_links\s*=\s*(yes|true|1)\s*$/ig;
      $do_initrd       = "Yes" if /do_initrd\s*=\s*(yes|true|1)\s*$/ig;
      $use_hard_links  = "Yes" if /use_hard_links\s*=\s*(yes|true|1)\s*$/ig;
      $silent_modules  = 'Yes' if /silent_modules\s*=\s*(yes|true|1)\s*$/ig;
      $silent_loader   = 'Yes' if /silent_loader\s*=\s*(yes|true|1)\s*$/ig;
      $minimal_swap    = 'Yes' if /minimal_swap\s*=\s*(yes|true|1)\s*$/ig;

      $image_dest      = "$1"  if /image_dest\s*=\s*(\S+)/ig;
      $postinst_hook   = "$1"  if /postinst_hook\s*=\s*(\S+)/ig;
      $postrm_hook     = "$1"  if /postrm_hook\s*=\s*(\S+)/ig;
    }
    close CONF;
    $have_conffile = "Yes";
  }
}

# For some versions of kernel-package, we had this warning in the
# postinst, but the rules did not really interpolate the value in.
# Here is a sanity check.
my $pattern = "=" . "I";
$initrd=~ s/^$pattern$//;

# no floppy disk support available for m68k VME, and it is not very useful
# to make a boot floppy on PowerMac hardware at all.
$do_bootfloppy = "" if $loader =~ /^vmelilo/io;
$do_bootfloppy = "" if $loader =~ /^quik/io;
$do_bootfloppy = "" if $loader =~ /^yaboot/io;
$do_bootfloppy = "" if $loader =~ /^noloader/io;
$do_bootfloppy = "" if $loader =~ /^zipl/io;
$do_bootfloppy = "" if $loader =~ /^elilo/io;

# We can't have boot floppies for initrd kernels
$do_bootfloppy = "" if $initrd;

if ($image_in_boot) {
  $image_dest = "/$image_dir/";
  $image_dest =~ s|^/*|/|o;
}

$image_dest = "$image_dest/";
$image_dest =~ s|/+$|/|o;

if (! -d "$image_dest") {
  die "Expected Image Destination dir ($image_dest) to be a valid directory!\n";
}

# sanity
if (!($do_bootfloppy || $do_bootloader)) {  $do_boot_enable = ''; }

# most of our work is done in $image_dest (nominally /)
chdir("$image_dest") or die "could not chdir to $image_dest:$!\n";

# Paranoid check to make sure that the correct value is put in there
if (! $kimage)                    { $kimage = "vmlinuz";} # Hmm. empty
elsif ($kimage =~ m/^b?zImage$/o) { $kimage = "vmlinuz";} # these produce vmlinuz
elsif ($kimage =~ m/^[iI]mage$/o) { my $nop = $kimage;  }
elsif ($kimage =~ m/^vmlinux$/o)  { my $nop = $kimage;  }
else                              { $kimage = "vmlinuz";} # Default

die "Internal Error: Could not find image (" . $realimageloc
  . "$kimage-$version)\n" unless -e $realimageloc
  . "$kimage-$version";

# search for the boot loader in the path
my $loader_exec;
($loader_exec = $loader)  =~ s|.*/||;
my ($loaderloc) = grep -x, map "$_/$loader_exec",
  map { length($_) ? $_ : "." }  split /:/, $ENV{PATH};


######################################################################
######################################################################
###########        Test whether a relative symlinkwould be OK #######
######################################################################
######################################################################
sub test_relative {
  my %params = @_;
  my $cwd;

  die "Internal Error: Missing Required paramater 'Old Dir' "
    unless $params{'Old Dir'};
  die "Internal Error: Missing Required paramater New Dir' "
    unless  $params{'New Dir'};


  die "Internal Error: No such dir $params{'Old Dir'} "
    unless -d $params{'Old Dir'};
  die "Internal Error: No such dir $params{'New Dir'} "
    unless -d $params{'New Dir'};

  chomp($cwd = `pwd`);
  chdir ($params{'New Dir'}) or die "Could not chdir to $params{'New Dir'}:$!";
  my $ok = 0;
  $params{'Old Dir'}  =~ s|^/*||o;
  if (-d $params{'Old Dir'} ) {
    $ok = 1;
  }
  chdir ($cwd) or die "Could not chdir to $params{'New Dir'}:$!";
  return $ok;
}

######################################################################
######################################################################
############
######################################################################
######################################################################
sub CanonicalizePath {
  my $path = join '/', @_;
  my @work = split '/', $path;
  my @out;
  my $is_absolute;

  if (@work && $work[0] eq "") { $is_absolute = 1; shift @work; }

  while (@work) {
    my $seg = shift @work;
    if ($seg eq "." || $seg eq "") {
    } elsif ($seg eq "..") {
      if (@out && $out[-1] ne "..") {
	pop @out;
      } else {
	# Leading "..", or "../..", etc.
	push @out, $seg;
      }
    } else {
      push @out, $seg;
    }
  }

  unshift @out, "" if $is_absolute;
  return join('/', @out);
}
######################################################################
######################################################################
############
######################################################################
######################################################################

sub spath {
  my %params = @_;

  die "Missing Required paramater 'Old'" unless $params{'Old'};
  die "Missing Required paramater 'New'" unless  $params{'New'};

  my @olddir  = split '/', CanonicalizePath $params{'Old'};
  my @newdir  = split '/', CanonicalizePath $params{'New'};
  my @outdir  = @olddir;

  my $out = '';
  my $i;
  for ($i = 0; $i <= $#olddir && $i <= $#newdir; $i++) {
    $out++ if ($olddir[$i] ne $newdir[$i]);
    shift @outdir unless $out;
    unshift @outdir, ".." if $out;
  }
  if ($#newdir > $#olddir) {
    for ($i=$#olddir; $i < $#newdir; $i++) {
      unshift @outdir, "..";
    }
  }
  return join ('/', @outdir);
}
######################################################################
######################################################################
############
######################################################################
######################################################################

sub really_move_image {
  my $kimage = $_[0];
  my $image_dest = $_[1];

  if (-e "$kimage-$version") {	# we should be in dir /, normally
    rename("$kimage-$version", "$kimage-$version.$$") ||
      die "failed to move " . $image_dest . "$kimage:$!";
  }
  my $ret = system("mv -f " . $realimageloc . "$kimage-$version " .
		   " $kimage-$version");
  if ($ret) {
    die("Failed to move " . $realimageloc . "$kimage-$version to "
	. $image_dest . "$kimage-$version.\n");
  }
  # Ok, now we may clobber the previous .old files
  if (-e "$kimage-$version.$$") {
    rename("$kimage-$version.$$", "$kimage-$version.old") ||
      die "failed to move " . $image_dest . "$kimage:$!";
  }
  if ($reverse_symlink) {
    my $Old = $image_dest;
    if (test_relative ('Old Dir' => $Old, 'New Dir' => $realimageloc)) {
      $Old   =~ s|^/*||o;
    } elsif ($relative_links) {
      $Old = spath('Old' => "$Old", 'New' => "$realimageloc" );
    }
    if ($use_hard_links =~ m/YES/i) {
      link($Old . "$kimage-$version",
	   $realimageloc . "$kimage-$version")
	|| die("Failed to symbolic-link " . $image_dest .
	       "$kimage-$version to " . $realimageloc .
	       "$kimage-$version .\n");
    } else {
      symlink($Old . "$kimage-$version",
	      $realimageloc . "$kimage-$version")
	|| die("Failed to link " . $image_dest .
	       "$kimage-$version to " . $realimageloc .
	       "$kimage-$version .\n");
    }
  }
}

sub image_magic {
  my $kimage = $_[0];
  my $image_dest = $_[1];

  # Well, in any case, if the destination is a directory, we should do
  # nothing, except throw a diagnostic.
  if (-d "$kimage" ) {
    die ("Hmm. $kimage is a directory, which I did not expect.  I am\n" .
	 "trying to create a symbolic link with that name linked to \n" .
	 "$image_dest . Since a directory exists here, my assumptions \n" .
	 "are way off, and I am aborting.\n" );
    exit (3);
  }


  if ($move_image)
    {     # Maybe $image_dest is in on dos, or something?
      really_move_image($kimage, $image_dest);
      return;
    }


  if (-l "$kimage")
    {  # There is a symbolic link
      my $force_move = 0;

      if ($no_symlink || $reverse_symlink)
	{	# we do not want links, yet we have a symbolic link here!
	  warn "found a symbolic link in " . $image_dest . "$kimage \n" .
	    "even though no_symlink is defined\n" if $no_symlink;
	  warn "found a symbolic link in " . $image_dest . "$kimage \n" .
	    "even though reverse_symlink is defined\n" if $reverse_symlink;
	  # make sure we change this state of affairs
	  $force_move = 1;
	}
      else
	{
	  my $vmlinuz_target = readlink "$kimage";
	  my $target = CanonicalizePath("$realimageloc" . "$kimage-$version");

	  if (!defined($vmlinuz_target))
	    {	# what, a dangling symlink?
	      warn "The link "  . $image_dest . "$kimage is a dangling link\n";
	      $force_move = 1;
	    }
	  else
	    {
	      my $cwd;
	      chomp ($cwd=`pwd`);
	      if ($vmlinuz_target !~ m|^/|o)
		{
		  $vmlinuz_target = $cwd . "/" . $vmlinuz_target;
		  $vmlinuz_target =~ s|/+|/|o;
		}
	      $vmlinuz_target = CanonicalizePath($vmlinuz_target);
	      if ("$vmlinuz_target" ne "$target")
		{
		  if ($minimal_swap) 
		    {
		      if (-l "$kimage.old")
			{
			  my $old_target = readlink "$kimage.old";
			  if ($old_target !~ m|^/|o)
			    {
			      $old_target = $cwd . "/" . $old_target;
			      $old_target =~ s|/+|/|o;
			    }
			  $old_target = CanonicalizePath($old_target);
			  if ("$old_target"  ne "$target")
			    {
			      $force_move = 1;
			    }
			  else
			    {
			      warn "$kimage.old --> $target -- doing nothing";
			      $force_move = 0;
			    }
			}
		      else
			{
			  $force_move = 1;
			}
		    }
		  else 
		    {
		      $force_move = 1;
		    }
		}
	      else
		{
		  warn "$vmlinuz_target points to $target -- doing nothing";
		  $force_move = 0;
		}
	    }
	}
      if ($force_move)
	{      # don't clobber $kimage.old quite yet
	  rename("$kimage", "$kimage.$$") ||
	    die "failed to move " . $image_dest . "$kimage:$!";
	  my $Old = $realimageloc;
	  my $cwd;
	  chomp($cwd=`pwd`);
	  if (test_relative ('Old Dir' => $Old, 'New Dir' => $cwd))
	    {
	      $Old   =~ s|^/*||o;
	    }
	  elsif ($relative_links)
	    {
	      $Old = spath('Old' => "$Old", 'New' => $cwd);
	    }
	  if ($use_hard_links =~ m/YES/i)
	    {
	      if (! link($Old . "$kimage-$version", "$kimage"))
		{
		  rename("$kimage.$$", "$kimage");
		  die("Failed to link " . $realimageloc .
		      "$kimage-$version to "  . $image_dest . "$kimage .\n");
		}
	    }
	  else
	    {
	      if (! symlink($Old . "$kimage-$version", "$kimage"))
		{
		  rename("$kimage.$$", "$kimage");
		  die("Failed to symbolic-link " . $realimageloc .
		      "$kimage-$version to " . $image_dest . "$kimage .\n");
		}
	    }

	  # Ok, now we may clobber the previous .old file
	  if (-l "$kimage.old" || ! -e "$kimage.old" )
	    {
	      rename("$kimage.$$", "$kimage.old");
	    }
	  else
	    {
	      warn "$kimage.old is not a symlink, not clobbering\n";
	      unlink "$kimage.$$";
	    }
	}
    }
  elsif (! -e "$kimage")
    {
      # Hmm. Pristine system? How can that be?
      # Possibly they do not want a link here. (we should be in /
      # here[$image_dest, really]
      warn "$image_dest" .
	"$kimage does not exist. Installing from scratch, eh?\n";
      warn "Or maybe you don't want a symbolic link here. Hmm? Lets See.\n";
      if ($no_symlink) {
	my $ret = system("cp -a --backup=t " . $realimageloc .
			 "$kimage-$version "   . " $kimage");
	if ($ret)
	  {
	    die("Failed to copy " . $realimageloc . "$kimage-$version to "
		. $image_dest . "$kimage .\n");
	  }
      }
      elsif ($reverse_symlink)
	{
	  my $ret = system("mv -f " . $realimageloc . "$kimage-$version "
			   . "$kimage");
	  if ($ret)
	    {
	      die("Failed to move " . $realimageloc . "$kimage-$version to "
		  . $image_dest . "$kimage .\n");
	    }
	}
      else
	{
	  if (! $have_conffile)
	    {
	      my $answer='';

	      print STDERR "I notice that you do not have $kimage symbolic\n";
	      print STDERR "link. I can create one for you, and it shall be\n";
	      print STDERR "updated by newer kernel image packages. This is\n";
	      print STDERR "useful if you use a boot loader like lilo.\n";
	      print STDERR "Do you want me to create a link from " .
		$realimageloc . "$kimage-$version to $kimage?[Yn] ";
	      $answer=<STDIN>;
	      $do_symlink = "No" if $answer =~ /n/i;

	      if (open(CONF, ">$CONF_LOC"))
		{
		  if ($loader =~ /palo/i)
		    {
		      print CONF "image_in_boot = Yes\n";
		      print CONF "do_symlinks = Yes\n";
		      print CONF "relative_links = Yes\n";
		      print CONF "do_bootfloppy = No\n";
		      print CONF "do_bootloader = No\n";
		    }
		  else
		    {
		      print CONF "# Do not create symbolic links in /\n";
		      print CONF "do_symlinks = $do_symlink\n";
		    }
		  close CONF;
		}
	      $have_conffile = "Yes";
	    }
	}
      if ($do_symlink =~ /Yes/i)
	{
	  if ($reverse_symlink)
	    {
	      my $Old = $image_dest;
	      if (test_relative ('Old Dir' => $Old,
				 'New Dir' => $realimageloc))
		{
		  $Old   =~ s|^/*||o;
		}
	      elsif ($relative_links)
		{
		  $Old = spath('Old' => "$Old", 'New' => $realimageloc);
		}
	      symlink($Old . "$kimage", $realimageloc . "$kimage-$version")
		|| die("Failed to symbolic-link " . $realimageloc
		       . "$kimage-$version to " . $image_dest . "$kimage .\n");
	    }
	  else
	    {
	      my $Old = $realimageloc;
	      if (test_relative ('Old Dir' => $Old,
				 'New Dir' => $image_dest))
		{
		  $Old   =~ s|^/*||o;
		}
	      elsif ($relative_links)
		{
		  $Old = spath('Old' => "$Old", 'New' => $image_dest);
		}
	      symlink($Old . "$kimage-$version", "$kimage") ||
		die("Failed to symbolic-link " . $realimageloc
		    . "$kimage-$version to "  . $image_dest . "$kimage .\n");
	    }
	}
    }
  elsif ($no_symlink)
    {		# Maybe /$image_dest is on a dos system?
      if (-e "$kimage")
	{
	  rename("$kimage", "$kimage.$$") ||
	    die "failed to move " . $image_dest . "$kimage:$!";
	}
      my $ret = system("cp -a --backup=t " . $realimageloc
		       . "$kimage-$version " . "$kimage");

      if ($ret)
	{
	  if (-e "$kimage.$$") { rename("$kimage.$$", "$kimage"); }
	  die("Failed to copy " . $realimageloc . "$kimage-$version to "
	      . $image_dest . "$kimage .\n");
	}

      # Ok, now we may clobber the previous .old files
      if (-e "$kimage.$$") { rename("$kimage.$$", "$kimage.old");  }
    }
  elsif ($reverse_symlink)
    {  # Maybe /$image_dest is on a dos system?
      if (-e "$kimage")
	{
	  rename("$kimage", "$kimage.$$") ||
	    die "failed to move " . $image_dest . "$kimage:$!";
	}
      my $ret = system("mv -f " . $realimageloc . "$kimage-$version "
		       . $image_dest . "$kimage");
      if ($ret)
	{
	  if (-e "$kimage.$$") {rename("$kimage.$$", "$kimage");}
	  die("Failed to move " . $realimageloc . "$kimage-$version to "
	      . $image_dest . "$kimage .\n");
	}

      my $Old = $image_dest;
      if (test_relative ('Old Dir' => $Old, 'New Dir' => $realimageloc))
	{
	  $Old   =~ s|^/*||o;
	}
      elsif ($relative_links)
	{
	  $Old = spath('Old' => "$Old", 'New' => $realimageloc);
	}
      if ($use_hard_links =~ m/YES/i)
	{
	  if (! link($Old . "$kimage", $realimageloc . "$kimage-$version"))
	    {
	      warn "Could not link " . $image_dest .
		"$kimage to $kimage-$version :$!";
	    }
	}
      else
	{
	  if (! symlink($Old . "$kimage", $realimageloc . "$kimage-$version"))
	    {
	      warn "Could not symlink " . $image_dest .
		"$kimage to $kimage-$version :$!";
	    }
	}

      # Ok, now we may clobber the previous .old files
      if (-e "$kimage.$$") { rename("$kimage.$$", "$kimage.old");}
    }
  elsif (-f "$kimage" && $use_hard_links =~ m/YES/i )
    {
      # Ok then. this ought to be a hard link, and hence fair game
      # don't clobber $kimage.old quite yet
      rename("$kimage", "$kimage.$$") ||
	die "failed to move " . $image_dest . "$kimage:$!";
      my $Old = $realimageloc;
      my $cwd;
      chomp($cwd=`pwd`);
      if (test_relative ('Old Dir' => $Old, 'New Dir' => $cwd)) {
	$Old   =~ s|^/*||o;
      }
      elsif ($relative_links)
	{
	  $Old = spath('Old' => "$Old", 'New' => $cwd);
	}
      if (! link($Old . "$kimage-$version", "$kimage"))
	{
	  rename("$kimage.$$", "$kimage");
	  die("Failed to link " . $realimageloc . "$kimage-$version to "
	      . $image_dest . "$kimage .\n");
	}

      # Ok, now we may clobber the previous .old file
      rename("$kimage.$$", "$kimage.old");
    }
}

######################################################################
######################################################################
######################################################################
######################################################################

if ( -f "/lib/modules/$version/modules.dep" ) {
  my $running = '';
  chop($running=`uname -r`);
  if ($running eq $version) {
    print STDERR <<"EOFERR";

 You are attempting to install a kernel version that is the same as
 the version you are currently running (version $running). The modules
 list is quite likely to have been changed, and the modules dependency
 file /lib/modules/$version/modules.dep needs to be re-built. It can
 not be built correctly right now, since the module list for the
 running kernel are likely to be different from the kernel installed.
 I am creating a new modules.dep file, but that may not be
 correct. It shall be regenerated correctly at next reboot.

 I repeat: you have to reboot in order for the modules file to be
 created correctly. Until you reboot, it may be impossible to load
 some modules. Reboot as soon as this install is finished (Do not
 reboot right now, since you may not be able to boot back up until
 installation is over, but boot immediately after). I can not stress
 that too much. You need to reboot soon.

EOFERR
  ;

    my $answer='';
    print "Please Hit return to continue.  ";
    $answer=<STDIN>;
  }
}

# We may not have any modules installed
if ( -d "/lib/modules/$version" ) {
  my $ret = system("depmod -a -F $realimageloc/System.map-$version $version");
  # my $exit_value  = $? >> 8;
  # my $signal_num  = $? & 127;
  # my $dumped_core = $? & 128;
  if ($ret) {
    if ( -f "/lib/modules/$version/modules.dep") {
      unlink "/lib/modules/$version/modules.dep";
    }
    print "There was a problem running depmod.  This may be benign, \n";
    print "(You may have versioned symbol names, for instance).\n";
    print "Or this could be an error. In any case, since depmod is \n";
    print "run at install time, we could just defer running depmod\n";
    if (&ask_y("Would you like to abort now")) {
      exit (1);
    }
    else {
       print STFERR "Ok, continuing as directed\n";
    }
  }
}



# The initrd symlink should probably be in the same dir that the
# symlinks are in
if ($initrd) {
  my $ret = system("mkinitrd -o " . $realimageloc . "initrd.img-$version " .
		   "/lib/modules/$version");
  die("Failed to create initrd image.\n") if $ret;

  if ($initrd && -l "initrd" ) {
    print STDERR <<"EOIMG";

I Note that you have an old initrd symbolic link in place. The name of
the symbolic link is being changed to initrd.img I have two options
here.  I can: (A) delete the old symbolic link (default).  You shall
need to update the boot loader (b) Igore it and do nothing

EOIMG
  ;
   my $answer='';
    print "Please select one of a, or b: ";
    $answer=<STDIN>;
    if ($answer =~ /^\s*a/i) {
      unlink "initrd";
    }
    else {
      print STDERR
	"Please note that initrd points to the wrong image now\n";
    }
  }

  image_magic("initrd.img", $realimageloc) if $initrd;

  if ($initrd && -l "$image_dir/initrd" && ! $image_in_boot) {
    print STDERR <<"EOIMG";
I Note that you have an old $image_dir/initrd symbolic link in place.
The location of the symbolic link is now the same location as the kernel
image symbolic links, names, in $image_dest.  I have two options here.
I can:
 (A) delete the old symbolic link (default).  You shall need to update the
      boot loader
 (b) Igore it and do nothing
EOIMG
  ;
    my $answer='';
    print "Please select one of a, or b: ";
    $answer=<STDIN>;
    if ($answer =~ /^\s*a/i) {
      unlink "$image_dir/initrd";
    }
    else {
      print STDERR
	"Please note that $image_dir/initrd points to the wrong image now\n";
    }
  }
}

image_magic($kimage, $image_dest);

# We used to have System.* files in /
if (-e "/System.map" || -e "/System.old") {
  print STDERR <<"EOMAP";
 I notice that you have System.map symbolic links in /. These were
 installed by older kernel image packages. However, all the programs
 that look at the information in the map files (including top, ps, and
 klogd) also will look at /boot/System.map-<version>, we just need to
 ensure that that file is present, and no longer require the symbolic
 link.

 Actually, having the symbolic link in / is technically detrimental
 (apart from cluttering up /); many programs, though looking in /boot,
 still allow /System.map to override. If you use $Loader to choose
 between multiple kernels, then the /System.map symbolic link only
 applies to one such kernel, for all other choices the symbols loaded
 will be wrong. Not having the symbolic links at all prevents this.

 I can delete these symbolic links for you, if you wish.
EOMAP

  if (&ask_y("Would you like to delete the obsolete links now")){
    unlink '/System.map' if -e '/System.map';
    unlink '/System.old' if -e '/System.old';
    print STFERR "Obsolete links removed.\n";
  }
  else {
    print STFERR
      "Ok, not deleting the files. Please remember to remove them manually.\n";
  }
}

my $linktarget;
$linktarget = "../share/doc/kernel-image-$version";

if (-d "/usr/doc") {
  # Well, we still need to handle this, at least for the time being
  if (-d "/usr/share/doc/kernel-image-$version") {
    # So the new doc dir exists, goody
    if (-l "/usr/doc/kernel-image-$version") {
      unlink "/usr/doc/kernel-image-$version";
    }
    my $targetdir;
    my $stargetdir;
    if (-x '/bin/pwd') {
      # Oooh. Moving away from $image_dest (which is normally /, but
      # not always
      chdir('/usr/doc/');
      $targetdir=`/bin/pwd`;
      chdir('/usr/share/doc/');
      $stargetdir=`/bin/pwd`;

      chdir('/usr/doc');
      if (-f '../share/doc/') {
	chdir('../share/doc/');
	my $ltarget=`/bin/pwd`;
	if ($ltarget ne $stargetdir) {
	  $linktarget = "/usr/share/doc/kernel-image-$version";
	}
      }
      else {
	$linktarget = "/usr/share/doc/kernel-image-$version";
      }
    }
    # Make sure we are back where we want to be, in $image_dest[/]
    chdir("$image_dest") or die "could not chdir to $image_dest:$!\n";

    if ($targetdir ne $stargetdir) {
      if (-d "/usr/doc/kernel-image-$version") {
	print STDERR "Yikes! The old directory, /usr/doc/kernel-image-$version\n";
	print STDERR "has not been removed! This is an error; attempting\n";
	print STDERR "repairs";
	if (-f "/usr/doc/kernel-image-$version/.dhelp") {
	  unlink "/usr/doc/kernel-image-$version/.dhelp";
	  rmdir "/usr/doc/kernel-image-$version";
	}
	if (-d "/usr/doc/kernel-image-$version") {
	  print STDERR <<"EOFERRONE";
Failed repairs. There are old files in /usr/doc/$package_name/ created
by you or another script. I can copy them over to the new location
/usr/share/doc/$package_name, if you wish, preserving your versions of
the files.  No files shall be over written, instead, backup versions
shall be created in /usr/share/doc/$package_name as needed.

EOFERRONE
  ;
	  my $answer='';
	  print "Shall I copy the files over [Yn]?";
	  $answer=<STDIN>;
	  if ($answer =~ /^n/i) {
	    print "Not copying over, aborting\n";
	    exit 1;
	  }
	  else {
	    system "cp", "-a", "--backup=t",
	    "/usr/doc/kernel-image-$version",
	    "/usr/share/doc/kernel-image-$version/.." ||
	      die "Error copying files over: $?";
	    system "rm", "-rf", "/usr/doc/kernel-image-$version" ||
	      die "Error removing old directory:$?";
	  }
	}
      }
      if (-e "/usr/doc/kernel-image-$version") {
	print STDERR "/usr/doc/kernel-image-$version exists, but is not a directory\n";
	if (-l "/usr/doc/kernel-image-$version") {
	  print STDERR "It is a symbolic link. Overwriting\n";
	  unlink "/usr/doc/kernel-image-$version";
	  symlink $linktarget, "/usr/doc/kernel-image-$version";
	}
	else {
	  print STDERR "This is an error. Aborting\n";
	  exit 1;
	}
      }
      # File unexists. Free to go ahead and create link
      symlink $linktarget,  "/usr/doc/kernel-image-$version";
    }
  }
}

## Run user hook script here, if any
if (-x "$postinst_hook") {
    system ("$postinst_hook", $version, $realimageloc . "$kimage-$version") &&
	warn "User hook script $postinst_hook failed";
}



exit (0) unless $do_boot_enable;	# Exit if explicitly asked to

if ($loader =~ /noloader/io) {
    print STDERR << "MSGEND";
I have determined no bootloader is required for your architecure.  This is
either because there is no boot loader for your architecture, or because I
did not change anything that would cause the boot loader to be run.  However,
I could be wrong, and, if that is the case, I would appreciate it if you would
please report a bug against the kernel-package package.

Done.
MSGEND
;
    exit (0);
}


exit (0) if $loader =~ /silo/i; # SILO does not have to be executed.
exit (0) if $loader =~ /yaboot/i; # yaboot does not have to be executed.
exit (0) if $loader =~ /milo/i; # MILO does not have to be executed.
exit (0) if $loader =~ /nettrom/i; # NETTROM does not have to be executed.

exit (0) unless $loaderloc;


undef $rootdevice;
undef $rootdisk;
undef $rootpartition;
undef $bootdevice;

open(FSTAB, "</etc/fstab") || die "Could not open /etc/fstab:$!";

my $line = '';
while ( $line=<FSTAB> ) {
  my $device;
  my $filesystem;
  my $ftype;
  my $foption;
  my $islilo;

  if ( $line =~ m/^\#/ ) {
    next;
  }

  # ignore leading spaces.
  $line =~ s/^\s+//og;

#  ($device,$filesystem)=split(/[ \t]+/, $line);
  ($device,$filesystem,$ftype,$foption)=split(/[ \t]+/, $line);
  next unless $device =~ m|^/dev/|; #ignore NFS and proc systems
  next if $device =~ m|^/dev/fd|;   #ignore floppy drives
  next if $device =~ m|^/dev/pty|;  #ignore Pseudo-TTY masters
  next if $device =~ m|^/dev/tty|;  #ignore Pseudo-TTY slaves
  next if $device =~ m|^/dev/cu|;   #ignore obsolete device
  next if $device =~ m|^/dev/lp|;   #ignore printers
  next if $device =~ m|^/dev/vcs|;  #ignore Virtual console capture

  next if $filesystem =~ m|^none$|; #swap? in any case, do not run dd
  next if $foption =~ m|noauto|; # look for any FS not mounted at bootup time

  # Looking at linux/Documentation/devices.txt, We see that really we
  # should be looking for /dev/hd* (hard disk),  /dev/sd*. What about
  # metadisk devices? ram drives? I think I'll just leave this mess
  # well enough alone.

  if ( $filesystem =~ m!^/$! ) {
    $rootdevice = $device;
  }
  unless ($loader =~ /vmelilo/io) {
    $islilo=`dd if=$device ibs=1 skip=2 count=4 2>/dev/null`;
    if ($islilo =~ /$Loader/o) {
      $bootdevice = $device;
    }
  }
  if (defined($rootdevice) && defined($bootdevice)) {
    last;
  }
}
close(FSTAB);

if (! defined($rootdevice)) {
  my $answer;
  print "Could not find where the current root file system is mounted!\n";
  print "Please make some arrangements for your system to boot the new\n";
  print "kernel (like running LILO, loadlin, SILO, QUIK, VMELILO, or  \n";
  print "getting a boot floppy).                                      \n";
  print "Please hit return to continue.                               \n";
  $answer = <STDIN>;
  exit (0);
}
else {
  $rootdisk = $rootdevice;
  $rootdisk =~ s/[0-9]+$//;
  $rootpartition = $rootdevice;
  $rootpartition =~ s/$rootdisk//;
}

print "A new kernel image has been installed, and usually that means  \n";
print "that some action has to be taken to make sure that the new     \n";
print "kernel image is used next time the machine boots. Usually,     \n";
print "this entails running a ``bootloader'' like grub, SILO, loadlin,\n";
print "LILO, ELILO, QUIK, VMELILO, ZIPL, or booting from a floppy.   \n\n";

if ( ! -x "$loaderloc" ) {
  print "Hmm. $Loader";
  printf " (LInux LOader)"                     if $loader =~ /^lilo/i;
  printf " (Efi LInux LOader)"                 if $loader =~ /^elilo/i;
  printf " (Sparc Improved Linux lOader)"      if $loader =~ /^silo/i;
  printf " (QUIK: PowerMac Boot Loader)"       if $loader =~ /^quik/i;
  printf " (yaboot: PowerMac Boot Loader)"     if $loader =~ /^yaboot/i;
  printf " (PALO: PA-RISC Boot Loader)"        if $loader =~ /^palo/i;
  printf " (VMELILO: m68k VME Boot Loader)"    if $loader =~ /^vmelilo/i;
  printf " (ZIPL: s390 & zSeries Boot Loader)" if $loader =~ /^zipl/i;
  printf ", which is the boot loader I    \n";
  print "have additional help for, is not installed (it is, after all,\n";
  print "just one of many options). I am assuming you have made some  \n";
  print "other arrangements for your system to boot the new kernel.   \n";
  print "Please hit return to continue.                               \n";
  my $answer = <STDIN>;
  exit (0) unless defined $rootdevice;
  exit (0) if $loader =~ /^silo/i; # No idea how to make non SILO floppies
  exit (0) if $loader =~ /^quik/i;
  exit (0) if $loader =~ /^yaboot/i;
  exit (0) if $loader =~ /^palo/i; # No such thing as PALO floppies
  exit (0) if $loader =~ /^vmelilo/i;
  exit (0) if $loader =~ /^zipl/i;

  if ($do_bootfloppy) {
    print "I can make a non-LILO diskette instead, but it won't be as useful.\n";

    if (&ask_y("Would you like to create a boot floppy now")) {
      &makefloppy();
    }
  }
  exit(0);
}

@boilerplate = (
    "compact\n",
    "install=/boot/boot.b",
    "\nmap=/boot/map\n",
    "vga=normal\n",
    "delay=20\n",
    "image=" . $image_dest . "$kimage\n",
    "label = Linux\n",
    "read-only\n"
);

@silotemplate = (
   "partition=$rootpartition\n",
   "root=$rootdevice\n",
   "timeout=100\n",
   "image=" . $image_dest . "$kimage\n",
   "\tlabel = Linux\n",
   "\tread-only\n",
   "other=1\n",
   "\tbootblock=" . $rootpartition .  "/boot/old.b\n",
   "\tlabel = oldsys\n"
		);

@quiktemplate = (
   "partition=$rootpartition\n",
   "root=$rootdevice\n",
   "timeout=100\n",
   "image=" . $image_dest . "$kimage\n",
   "\tlabel = Linux\n",
   "\tread-only\n",
   "other=1\n",
   "\tbootblock=" . $rootpartition .  "/boot/old.b\n",
   "\tlabel=oldsys\n"
                );

@palotemplate = (
   "# See /usr/share/doc/palo/README.html and run 'palo --help' for\n",
   "# more information\n\n",
   "# $rootdevice $rootdisk $rootpartition $bootdevice\n",
   "--init-partitioned=$rootdisk\n",
   "--bootloader=/usr/share/palo/iplboot\n",
   "--recoverykernel=" . $image_dest . "$kimage\n",
   "--commandline=$rootpartition" . $image_dest . "$kimage root=$rootdevice\n",
                );

@vmelilotemplate = (
  "default   = Linux\n",
  "delay     = 2\n",
  "\n",
  "[boot]\n",
  "label     = Linux\n",
  "image     = " . $image_dest . "$kimage\n",
  "read-only\n"
                );

@zipltemplate = (
  "[defaultboot]\n",
  "default=debian\n",
  "\n",
  "[debian]\n",
  "target=/boot\n",
  "image=" . $image_dest . "$kimage\n",
  "parmfile=/boot/parmfile\n"
                );

if($loader =~ /^zipl/io)
  {
    $install_boot_method = "VM-reader or a boot tape";
  }
else
  {
    $install_boot_method = "a boot floppy";
  }


# creating some info about kernel and initrd
my $ksize=sprintf("%.0f",(stat($realimageloc .
			       "$kimage-$version"))[7]/1024)."kB";
if ($initrd) {
  my $initrdsize=sprintf("%.0f",(stat($realimageloc .
				      "initrd.img-$version"))[7]/1024)."kB";
}


print STDERR <<"EOMSG";
A new kernel image has been installed. at $realimageloc$kimage-$version
 (Size: $ksize)

EOMSG
;

if ($initrd) {
  print STDERR <<"EOMSGA";

 Initial rootdisk image: $realimageloc/initrd.img-$version (Size: $initrdsize)
EOMSGA
  ;
}

print STDERR <<"EOMSGB";

Symbolic links, unless otherwise specified, can be found in $image_dest

$Loader sets up your system to boot Linux directly from your hard
disk, without the need for booting from $install_boot_method.

WARNING
If you are keeping another operating system or another version
of Linux on a separate disk partition, you should not have $Loader
install a boot block now. Wait until you read the $Loader documentation.
That is because installing a boot block now might make the other
system un-bootable. If you only want to run this version of Linux,
go ahead and install the boot block here. If it does not work, you
can still boot this system from $install_boot_method.

EOMSGB
;

if ($do_bootfloppy) {
  if (&ask("Would you like to create a boot floppy now")) {
    &makefloppy();
  }
}

exit 0 unless $do_bootloader;


if (-T "/etc/$loader.conf") {
  # Trust and use the existing lilo.conf.
  print "You already have a $Loader configuration in /etc/$loader.conf\n";
  if ($silent_loader) {
    my $ret = &run_lilo();
    exit $ret;
  }
  elsif( &ask_y("Install a boot block using the existing /etc/$loader.conf")) {
    my $ret = &run_lilo();
    exit $ret;
  }
  elsif ($loader =~ /^elilo/io) {
    print "I don't know how to create an elilo.conf file from scratch,\n";
    print "sorry.  elilo can do that for you, if you invoke it with the\n";
    print "correct options.  Aborting.\n";
    exit(0);
  }
  else {
    if (&ask("Wipe out your old $Loader configuration and make a new one")){
      my $ret = system("savelog /etc/$loader.conf");
      if ($ret) {
	print "There was a problem saving a copy of your /etc/$loader.conf\n";
	print "Since this could have grave repercussions, I am aborting.\n";
	exit(0);
      }
    }
    else {
      exit (0);
    }
  }
}
elsif ($loader =~ /^elilo/io) {
  print "I don't know how to create an elilo.conf file from scratch,\n";
  print "sorry.  elilo can do that for you, if you invoke it with the\n";
  print "correct options.  Aborting.\n";
  exit(0);
}

if (! &ask_y("Do you wish to set up Linux to boot from the hard disk")) {
  exit (0);
}

if ($loader =~ /^lilo/io) {
  print <<EOF;

You must do three things to make the Linux system boot from the hard
disk. Install a partition boot record, install a master boot record,
and set the partition active. You will be asked to perform each of
these tasks. You may skip any or all of them, and perform them
manually later on
EOF
  ;

}

# If we get this far, we need to make a new lilo conf, and run lilo
&make_liloconf();

{ my $q;
  if ($loader =~ /vmelilo/io) {
    $q = "Install a boot block on $bootdevice";
  } else {
    $q = "Install a partition boot block on partition $bootdevice";
  }
  if (&ask_y($q)) {
    my $ret = &run_lilo();
    exit $ret if $ret;
  }
}

if ($loader =~ /^lilo/io) {
  print "\n";
  print "A master boot record is required to run the partition boot record.\n";
  if (-f "/boot/mbr.b") {
    print "If you are already using a boot manager, and want to keep it,\n";
    print "answer \"no\" to the following question. If you don't know\n";
    print "what a boot manager is or whether you have one, answer \"yes\".\n";
    if ( &ask_y("Install a master boot record (/boot/mbr.b) on $rootdisk")) {
      my $ret = system("dd if=/boot/mbr.b of=$rootdisk bs=444 count=1");
      if ($ret) {
	print "There was a problem copying the master boot record.\n";
	print "Please run \"dd if=/boot/mbr.b of=$rootdisk bs=444 count=1\"\n";
	print "by hand. Please hit return to continue.\n";
	my $ans = <STDIN>;
      }
    }
  }
  else {
    print "However, you do not seem to have /boot/mbr.b, provided by the\n";
    print "Debian package mbr.  I hope that your master boot record or \n";
    print "boot manager does boot the active partition.  If not, you have\n";
    print "to acquire the package mbr and install it. Please hit return to\n";
    print "proceed.\n";
    my $ans = <STDIN>;
  }
  print "\n";
  print "The master boot record will boot the active partition.\n";
  print "If you want your system to boot another operating system,\n";
  print "such as DOS or Windows, by default, answer \"no\" to the following\n";
  print "question. You may still use your boot manager or the master\n";
  print "boot record to boot Linux. If you want the system to boot Linux.\n";
  print "by default, answer \"yes\".\n";
  if ( &ask_y("Make $rootdevice the active partition") ) {
    my $ret = system("/sbin/activate $rootdisk $rootpartition");
    if ($ret) {
      print "There was an error trying to activate $rootdevice.\n";
      print "Please run \"/sbin/activate $rootdisk $rootpartition\"\n";
      print "by hand. Please hit return to proceed.\n";
      my $ans = <STDIN>;
    }
  }
  else {
    print "\n";
    print "OK. If you installed the master boot record, and the partition\n";
    print "boot record, you may boot Linux by holding down the shift key\n";
    print "as the system boots, and then pressing the $rootpartition key\n";
    print "when you see the \"1234F:\" prompt.\n";
    print "";
    print "For more information, see /usr/doc/mbr/README, and the files\n";
    print "in the /usr/doc/$loader directory.\n";
  }
}
else {
  if (-f "/boot/old.b") {
    print "$loader has overwritten the original boot loader and saved it under\n";
    print "/boot/old.b.  You can boot your old system (if any) using the\n";
    print "oldsys label at the $loader prompt.\n";
  }
}

sub ask {
  my $answer;
  print @_,"? [No] ";
  $answer=<STDIN>;
  return ( $answer =~ /^\s*y/i );
}

sub ask_y {
  my $answer;
  print @_,"? [Yes] ";
  $answer=<STDIN>;
  return ( $answer !~ /^\s*n/i );
}

sub makefloppy {
  my $answer;
  my $done = 0;
  my $drive = 0;
  my $imageloc = '';

  return unless $do_bootfloppy;

  if ($no_symlink || $reverse_symlink) {
    $imageloc = $image_dest . $kimage;
  }
  else {
    $imageloc = $realimageloc . "$kimage-$version";
  }

  if (-e $imageloc) {
    my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
	$atime,$mtime,$ctime,$blksize,$blocks)
      = stat ($imageloc);
    if ($size >= 520192) {
      print STDERR "Please note that the system size is $size\n";
      print STDERR "This is greater than the size that the kernel\n";
      print STDERR "loader supports on i386 machines. What this\n";
      print STDERR "means is that you need to use lilo to boot\n";
      print STDERR "this kernel on i386 machines; the floppy is\n";
      print STDERR "not going to be sufficient by itself on an \n";
      print STDERR "i386 box. Of course, things may have changed since\n";
      print STDERR "July 2000, when this diagnostic was written. Your\n";
      print STDERR "Mileage may indeed vary. Please consider yourselves\n";
      print STDERR "warned.\n";
      print STDERR "Please hit return to continue.";
      $answer=<STDIN>;
    }
  }
  else {
    print STDERR "Ulp!. I couldn't find the image where I expected\n";
    print STDERR "it to be, namely, $imageloc\n";
    print STDERR "You shall have to create the floppy manually, I'm\n";
    print STDERR "afraid, using commands like\n";
    print STDERR "\tdd if=/path/to/$kimage-$version of=/dev/fd$drive\n";
    print STDERR "\trdev /dev/fd$drive $rootdevice\n";
    print STDERR "\trdev -R /dev/fd$drive 1\n";
    print STDERR "Aborting\n";
    return;
  }


  print <<EO_MSG_A;

This process needs a formatted floppy. Please note that an unformatted
floppy will cause this process to fail, and may well need a reboot to
fix, and unfortunately, the system is not bootable yet.

The first thing to determine is which floppy drive you wish to use.
For most people, the default, which is the the default floppy drive,
referred to as /dev/fd0, or A: would work.  Some people may want the
second floppy drive which is drive 1, or /dev/fd1, or B:.
(Theoretically there could be 8 floppy drives on a machine) If
in doubt, accept the default [0], which should work in most cases.

EO_MSG_A
  ;

  print "Which floppy drive [0-7] do you want to use? [0] ";
  $answer=<STDIN>;
  if ($answer =~ m/^\s*(\d+)\s*$/) {
    $drive = $1;
  }
  print "\nOk, using drive at /dev/fd$drive.\n\n";

  if (-x "/usr/bin/superformat") {
      print "If there is no formatted floppy available, I could attempt\n";
      print "to format it for you.\n";
      if (&ask("Do you wish me to format the floppy")){
         my $ret;
	 my $format_command = '/usr/bin/superformat';

         print "Insert a floppy diskette into your boot drive \n";
         print "(/dev/fd$drive) and press <Return> when ready:";
         $answer=<STDIN>;
        FMTFLOPPY: while (! $done) {
         DOFORMAT:{
              $ret = system $format_command, "/dev/fd$drive";
              last DOFORMAT if $ret;
              $done = 1;
           }
           if (! $done) {
	     print <<EO_MSG_B;

There was a problem formatting the floppy diskette in /dev/fd$drive

Please make sure that you inserted the disk in the correct drive and
that the disk is not write-protected.  Also, you may have to run
setfdprm for fdformat to work.

In some rare cases, it may mean a problem with the Floppy or the drive
it self (try formatting the floppy with
      % $format_command  /dev/fd$drive
manually to make sure if the problem persists).  In case the problem
persists, it maybe because you have an older fdformat which has a
problem auto- detecting the floppy drive.  Upgrading to the latest
fdutils may help, or maybe you need to run
      % setfdprm /dev/fd$drive 1440/1440
(or something like that) or you may try some thing like
      % $format_command  /dev/fd0H1440
 or even
      % $format_command  /dev/fd0u1440
manually which _may_ work. Or else, try a new floppy.

EO_MSG_B
  ;


             if (! &ask_y("Would you like to try again")) {
		print "\n";
		print "If there are no pre-formatted floppies available, \n";
		print "you should stop right here. \n";
		if (! &ask_y("Do you have a blank pre-formatted floppy")){
		  print "Ok, aborting.\n";
		  print "\n";
		  return 1;
		}
		print "\n";
              	last FMTFLOPPY;
             }
           }
         }
      }
  }
  else {
       print "If there are no pre-formatted floppies available, you\n";
       print "should stop right here. \n";
      if (! &ask_y("Do you have a blank pre-formatted floppy")){
	print "Ok, aborting.\n";
        return 1;
      }
  }
  if (!$done) {
      print "\n";
      print "Insert a (formatted) floppy diskette into your boot drive\n";
      print "(/dev/fd$drive) and press <Return> when ready:";
      $answer=<STDIN>;
  }
  $done=0;
  while (! $done) {
  MKBOOT:{
      my $ret;

      if ($loader =~ /^lilo/io) {
	if (-e "$imageloc") {
	  $ret = system '/bin/dd', "if=$imageloc", "of=/dev/fd$drive";
	  last MKBOOT if $ret;
	  $ret = system '/usr/sbin/rdev', "/dev/fd$drive", "$rootdevice";
	  last MKBOOT if $ret;
	  $ret = system '/usr/sbin/rdev', '-R', "/dev/fd$drive", '1';
	}
	else {
	  print STDERR "Ulp!. I couldn't find the image where I expected\n";
	  print STDERR "it to be, namely, $imageloc\n";
	  print STDERR "You shall have to create the floppy manually, I'm\n";
	  print STDERR "afraid, using commands like\n";
	  print STDERR "\tdd if=/path/to/$kimage-$version of=/dev/fd$drive\n";
	  print STDERR "\trdev /dev/fd$drive $rootdevice\n";
	  print STDERR "\trdev -R /dev/fd$drive 1\n";
	  print STDERR "Aborting\n";
	  return;
	}
      }
      else {
	$ret = &silo_floppy( $drive );
      }
      last MKBOOT if $ret;
      $done = 1;
      print "\n";
    }
    if (! $done) {
      print "\nThere was a problem creating the boot diskette in \n";
      print "/dev/fd$drive\n.";
      print "Please make sure that you inserted the diskette into the\n";
      print "correct drive and that the diskette is not write-protected.\n";
      print "In some rare cases, it may mean a problem with the\n";
      print "Floppy or the drive it self.\n";
      if (! &ask_y("Would you like to try again")) {
	$done = 1;
      }
      else {
	# don't display the next message if no more tries
	print "\n";
	print "Insert a (formatted) floppy diskette into your boot drive\n";
	print "/dev/fd$drive and press <Return> when ready:";
	$answer=<STDIN>;
      }
    }
  }
}

sub silo_floppy {
  my $drive = shift;
  my $mountpoint = "/var/lib/kernel.mntpoint.$$";
  my $ret = system '/sbin/mke2fs', "/dev/fd$drive";
  return $ret if $ret;
  $ret = mkdir $mountpoint, 0755;
  return $ret if $ret;
  $ret = system '/bin/mount', '-t', 'ext2', "/dev/fd$drive", $mountpoint;
  do { rmdir $mountpoint; return $ret } if $ret;
  do {
    mkdir $mountpoint . "/boot", 0755;
    last unless system '/bin/cp', '/boot/first.b', $mountpoint . '/boot';
    last unless system '/bin/cp', '/boot/second.b', $mountpoint . '/boot';
    if ($no_symlink || $reverse_symlink) {
      $ret = system '/bin/cp', $image_dest . $kimage, $mountpoint . '/linux';
    }
    else {
      $ret = system '/bin/cp', "$realimageloc" . "$kimage-$version",
                       $mountpoint . '/linux';
    }
    last if $ret;
    mkdir( $mountpoint . "/etc", 0755 ) || last;
    open SILO, ">$mountpoint/etc/silo.conf" || last;
    print SILO
       "partition=1\n",
       "root=/dev/fd$drive\n",
       "read-write\n",
       "timeout=100\n",        # 10s
       "image = /linux\n",
       "\tlabel = Linux\n",
       "\tappend=root=$rootdevice\n";
    close SILO;
    $ret = system '/sbin/silo', '-r', $mountpoint;
  };
  system '/bin/umount', $mountpoint;
  rmdir $mountpoint;
  return $ret;
}


sub make_liloconf {
  # Create a lilo.conf if one doesn't exist.
  if (!defined($bootdevice)) {
    if ($loader =~ /vmelilo/io) {
      print "\nPutting the boot record on to $rootdisk which is\n";
      print "the device where the root file system lives.\n\n";
      $bootdevice = $rootdisk;
    }
    else {
      print "\nHmm... I can't determine which partition to put the \n";
      print "partition boot record on. I'm defaulting to the $rootdevice\n";
      print "which is where the root file system lives.\n";
      $bootdevice = $rootdevice;
    }
  }

  open(CONF, ">/etc/$loader.conf");
  if ($loader =~ /^lilo/io) {
    print CONF "boot=".$bootdevice, "\n", "root=".$rootdevice, "\n",
               @boilerplate;
    if ($initrd) {
      print CONF "initrd=" . $image_dest . "initrd.img\n";
    }
  }
  elsif ($loader =~ /^vmelilo/io) {
    print CONF "boot      = $bootdevice\n",
               "root      = $rootdevice\n",
               @vmelilotemplate;
  }
  elsif ($loader =~ /^quik/io) {
    print CONF @quiktemplate;
  }
  elsif ($loader =~ /^palo/io) {
    print CONF @palotemplate;
  }
  elsif ($loader =~ /^zipl/io) {
    print CONF @zipltemplate;
  }
  else {
    print CONF @silotemplate;
  }
  close(CONF);
  chmod("/etc/$loader.conf", 0644);
  chown("/etc/$loader.conf", 0, 0);
}

sub run_lilo (){
  my $ret;
  if ($loader =~ /^lilo/io or $loader =~ /vmelilo/io) {
    print "Testing $loader.conf ... \n";
    unlink $temp_file_name;                        # security
    $ret = system("$loaderloc -t >$temp_file_name 2>&1");
    if ($ret) {
      my $ans;
      print "An error occurred while running $loader in test mode, a log is\n";
      print "available in $temp_file_name. Please edit /etc/$loader.conf\n";
      print "manually and re-run $loader, or make other arrangements to boot \n";
      print "your machine. \n\t Please hit return to continue";
      $ans = <STDIN>;
      return $ret;
    }
    unlink "$temp_file_name";
    print "Testing successful.\n";
    print "Installing the ";
    print "partition " if $loader =~ /^lilo/io;
    print "boot sector... \n";
  }

  if ($loader =~ /^elilo/io) {
    $ret = system("$loaderloc 2>&1 | tee $temp_file_name");
  }
  else {
    $ret = system("$loaderloc >$temp_file_name 2>&1");
  }

  if ($ret) {
    my $ans;
    print "There was an error with running $loader, a log file is \n";
    print "available in file $temp_file_name.  Please edit /etc/$loader.conf\n";
    print "manually and re-run $loader, or make other arrangements to boot \n";
    print "your machine. \n\t Please hit return to continue";
    $ans = <STDIN>;
    return $ret;
  }
  unlink $temp_file_name;
  print "Installation successful.\n";
  return 0;
}

exit 0;

__END__

