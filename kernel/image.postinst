#! /usr/bin/perl
#                              -*- Mode: Perl -*- 
# debian.postinst --- 
# Author           : Manoj Srivastava ( srivasta@pilgrim.umass.edu ) 
# Created On       : Sat Apr 27 05:55:26 1996
# Created On Node  : melkor.pilgrim.umass.edu
# Last Modified By : Manoj Srivastava
# Last Modified On : Fri Oct  8 05:43:39 1999
# Last Machine Used: glaurung.green-gryphon.com
# Update Count     : 107
# Status           : Unknown, Use with caution!
# HISTORY          : 
# Description      : 
# 
#    $Id: image.postinst,v 1.31 1999/11/30 06:15:37 srivasta Exp $
#

# 
# use strict; #for debugging
$|=1;
# Predefined values:
my $version         = "=V";
my $image_in_boot   = "=B";	# Should be empty, mostly
my $no_symlink      = "=S";	# Should be empty, mostly
my $reverse_symlink = "=R";	# Should be empty, mostly
my $kimage          = "=K";	# Should be empty, mostly
my $loader          = "=L";     # lilo, silo, quik, or nettrom
my $image_dest      = "=D";     # where the image is located

my $Loader          = "LILO";
$Loader             = "SILO"  if $loader =~ /silo/io;
$Loader             = "QUIK"  if $loader =~ /quik/io;
$Loader             = "NETTROM"  if $loader =~ /nettrom/io;

if (! $image_dest) {
  $image_dest         = "boot"  
}
else {
  $image_dest  =~ s|^/||o;
}


# This should not point to /tmp, because of security risks.
my $temp_file_name = "/var/log/$loader" . "_log.$$";

#known variables
my @boilerplate = ();
my $bootdevice = '';
my $rootdevice = '';
my $rootdisk = '';
my $rootpartition = '';
my $imagedir = "/";
my $realimageloc = "$image_dest/";


if ($image_in_boot) {
  $imagedir = "/$image_dest/";
  $realimageloc = "";
}

# Ignore all invocations uxcept when called on to configure.
exit 0 unless $ARGV[0] =~ /configure/;

# most of our work is done in $imagedir
chdir("$imagedir") or die "could not chdir to $imagedir:$!\n";

# Paranoid check to make sure that the correct value is put in there
if (! $kimage) {		# Hmm. empty
  $kimage = "vmlinuz"
}
elsif ($kimage =~ m/^b?zImage$/o) { # these produce vmlinuz
  $kimage = "vmlinuz"
}
elsif ($kimage =~ m/^Image$/o) {
  my $nop = $kimage;
}
elsif ($kimage =~ m/^vmlinux$/o) {
  my $nop = $kimage;
  #
}
else {				# Let this be the default as well
  $kimage = "vmlinuz"
}

if (-l "$kimage") {
  # There is a symbolic link
  my $force_move = 0;
  
  if ($no_symlink || $reverse_symlink) {
    # we do not want links, yet we have a symbolic link here!
    warn "found a symbolic link in " . $imagedir . "$kimage \n" .
      "even though no_symlink is defined\n" if $no_symlink;
    warn "found a symbolic link in " . $imagedir . "$kimage \n" .
      "even though reverse_symlink is defined\n" if $reverse_symlink;
    # make sure we change this state of affairs
    $force_move = 1;
  }
  # follow link target.  
  if (!$force_move) {
    my $vmlinuz_target = readlink "$kimage";
    if (!defined($vmlinuz_target)) {
      # what, a dangling symlink?
      warn "The link "  . $imagedir . "$kimage is a danglink link\n";
      $force_move = 1;
    }
    elsif ("$vmlinuz_target" eq "$realimageloc" . "$kimage-$version") {
      $force_move = 1;
    }
  }

  if ($force_move) {
    # don't clobber $kimage.old quite yet
    rename("$kimage", "$kimage.$$") || 
      die "failed to move " . $imagedir . "$kimage:$!";
    
    if (! symlink($realimageloc . "$kimage-$version", "$kimage")) {
      rename("$kimage.$$", "$kimage");
      die("Failed to symbolic-link /$image_dest/$kimage-$version to "
	  . $imagedir . "$kimage .\n"); 
    }
    
    # Ok, now we may clobber the previous .old file
    rename("$kimage.$$", "$kimage.old");
  }
}
elsif (! -e "$kimage") {
  # Hmm. Pristine system? How can that be?
  warn "$imagedir" . "$kimage does not exist. Installing from scratch, eh?\n";
  if ($no_symlink) {
    if (! rename($realimageloc . "$kimage-$version", "$kimage")) {
      die("Failed to move /$image_dest/$kimage-$version to "
	  . $imagedir . "$kimage .\n"); 
    }
  }
  elsif ($reverse_symlink) {
    if (! rename($realimageloc . "$kimage-$version", "$kimage")) {
      die("Failed to move /$image_dest/$kimage-$version to "
	  . $imagedir . "$kimage .\n"); 
    }
  }
  else {
    if (! symlink($realimageloc . "$kimage-$version", "$kimage")) {
      die("Failed to symbolic-link /$image_dest/$kimage-$version to "
	  . $imagedir . "$kimage .\n");
    }
  }
}
elsif ($no_symlink) {		# Maybe /$image_dest is on a dos system?
  rename("$kimage", "$kimage.$$") || 
      die "failed to move " . $imagedir . "$kimage:$!";
  if (! rename($realimageloc . "$kimage-$version", "$kimage")) {
    rename("$kimage.$$", "$kimage");
    die("Failed to move /$image_dest/$kimage-$version to "
	. $imagedir . "$kimage .\n"); 
  }
  
  # Ok, now we may clobber the previous .old files
  rename("$kimage.$$", "$kimage.old");
} 
elsif ($reverse_symlink) {		# Maybe /$image_dest is on a dos system?
  rename("$kimage", "$kimage.$$") || 
      die "failed to move " . $imagedir . "$kimage:$!";
  if (! rename($realimageloc . "$kimage-$version", "$kimage")) {
    rename("$kimage.$$", "$kimage");
    die("Failed to move /$image_dest/$kimage-$version to "
	. $imagedir . "$kimage .\n"); 
  }
  
  if (! symlink("$kimage", $realimageloc . "$kimage-$version")) {
    warn "Could not symlink $kimage to $kimage-$version :$!";
  }
  # Ok, now we may clobber the previous .old files
  rename("$kimage.$$", "$kimage.old");
} 
else {
  # Hmm, no link in /
  warn "Hmm, $kimage is not a link. Not changing it then.\n";
}

# We used to have System.* files in / 
if (-e "/System.map" || -e "/System.old") {
  print STDERR <<"EOMAP";
 I notice that you have System.map symbolic links in /. These were
 installed by older kernel image packages. However, all the programs
 that look at the information in the map files (including top, ps, and
 klogd) also will look at /boot/System.map-<version>, we just need to
 ensure that that file is present, and no longer require the symbolic
 link. 

 Actually, having the sumbolic link in / is technically detrimental
 (apart from cluttering up /); many programs, though looking in /boot,
 still allow /System.map to override. If you use $Loader to choose
 between multiple kernels, then the /System.map symbolic link only
 applies to one such kernel, for all other choices the symbols loaded
 will be wrong. Not having the symbolic links at all prevents this.

 I can delete these symbolic links for you, if you wish.
EOMAP
  
  if (&ask_y("Would you like to delete the obsolete links now")){
    unlink '/System.map' if -e '/System.map';
    unlink '/System.old' if -e '/System.old';
    print STFERR "Obsolete links removed.\n";
  }
  else {
    print STFERR 
      "Ok, not deleting the files. Please remember to remove them manually.\n";
  }
}

if ( -f "/lib/modules/$version/modules.dep" ) {
  my $running = '';
  chop($running=`uname -r`);
  if ($running eq $version) {
    print STDERR <<"EOFERR";

 You are attempting to install a kernel version that is the same as
 the version you are currently running (version $running). The modules
 list is quite likely to have been changed, and the modules dependency
 file /lib/modules/$version/modules.dep needs to be re-built. It can
 not be built correctly right now, since the module list for the
 running kernel are likely to be different from the kernel installed. 
 I am ccreating a new modules.dep file, but that may not be
 correct. It shall be regenrated correctly at next reboot.

 I repeat: you have to reboot in order for the modules file to be
 created correctly. Until you reboot, it may be impossible to load
 some modules. Re boot as soon as this install is finished (Do not re
 boot right now, since you may not be able to boot back up until
 installation is over, but boot immediately after). I can not stress
 that too much. You need to re boot soon. 

EOFERR
  ;
    
    my $answer='';
    print "Please Hit return to continue.  ";
    $answer=<STDIN>;
  }
  system("depmod -a $version");
}

if (-d "/usr/doc" && ! -l "/usr/doc") {
  # Well, we still need to handle this, at least for the time being
  if (-d "/usr/share/doc/kernel-image-$version") {
    # So the new doc dir exists, goody
    if (-d "/usr/doc/kernel-image-$version") {
      print STDERR "Yikes! The old directory, /usr/doc/kernel-image-$version\n";
      print STDERR "has not ben removed! This is an error; attempting\n";
      print STDERR "repairs";
      if (-f "/usr/doc/kernel-image-$version/.dhelp") {
	unlink "/usr/doc/kernel-image-$version/.dhelp";
	rmdir "/usr/doc/kernel-image-$version";
      }
      if (-d "/usr/doc/kernel-image-$version") {
	print STDERR <<"EOFERRONE";
Failed repairs. There are old files in /usr/doc/$package_name/ created
by you or another script. I can copy them over to the new location
/usr/share/doc/$package_name, if you wish, preserving your versions of
the files.  No files shall be over written, instead, backup versions
shall be created in /usr/share/doc/$package_name as needed.

EOFERRONE
  ;
	my $answer='';
	print "Shall I copy the files over [Yn]?";
	$answer=<STDIN>;
	if ($answer =~ /^n/i) {
	  print "Not copying over, aborting\n";
	  exit 1;
	}
	else {
	  system "cp", "-ab", "--version-control=t",
	  "/usr/doc/kernel-image-$version",
	  "/usr/share/doc/kernel-image-$version/.." ||
	    die "Error copying files over: $?";
	  system "rm", "-rf", "/usr/doc/kernel-image-$version" ||
	    die "Error removing old directory:$?";
	}
      }
    }
    if (-e "/usr/doc/kernel-image-$version") {
      print STDERR "/usr/doc/kernel-image-$version exists, but is not a directory\n";
      if (-l "/usr/doc/kernel-image-$version") {
	print STDERR "It is a symbolic link. Overwriting\n";
	unlink "/usr/doc/kernel-image-$version";
	symlink "../share/doc/kernel-image-$version",
	"/usr/doc/kernel-image-$version";
      }
      else {
	print STDERR "This is an error. Aborting\n";
	exit 1;
      }
    }
    # File unexists. Free to go ahead and create link
    symlink "../share/doc/kernel-image-$version",
    "/usr/doc/kernel-image-$version";
  }
}


exit (0) if $loader =~ /milo/i; # MILO does not have to be executed.
exit (0) if $loader =~ /nettrom/i; # NETTROM does not have to be executed.

undef $rootdevice;
undef $rootdisk;
undef $rootpartition;
undef $bootdevice;

open(FSTAB, "</etc/fstab") || die "Could not open /etc/fstab:$!";

my $line = '';
while ( $line=<FSTAB> ) {
  my $device;
  my $filesystem;
  my $ftype;
  my $foption;
  my $islilo;

  if ( $line =~ m/^\#/ ) {
    next;
  }

  # ignore leading spaces. 
  $line =~ s/^\s+//og;
  
#  ($device,$filesystem)=split(/[ \t]+/, $line);
  ($device,$filesystem,$ftype,$foption)=split(/[ \t]+/, $line);
  next unless $device =~ m|^/dev/|; #ignore NFS and proc systems
  next if $device =~ m|^/dev/fd|;   #ignore floppy drives
  next if $device =~ m|^/dev/pty|;  #ignore Pseudo-TTY masters
  next if $device =~ m|^/dev/tty|;  #ignore Pseudo-TTY slaves
  next if $device =~ m|^/dev/cu|;   #ignore obsolete device
  next if $device =~ m|^/dev/lp|;   #ignore printers
  next if $device =~ m|^/dev/vcs|;  #ignore Virtual console capture 

  next if $filesystem =~ m|^none$|; #swap? in any case, do not run dd
  next if $foption =~ m|noauto|; # look for any FS not mounted at bootup time

  # Looking at linux/Documentation/devices.txt, We see that really we
  # should be looking for /dev/hd* (hard disk),  /dev/sd*. What about
  # metadisk devices? ram drives? I think I'll just leave this mess
  # well enough alone.

  if ( $filesystem =~ m!^/$! ) {
    $rootdevice = $device;
  }
  $islilo=`dd if=$device ibs=1 skip=2 count=4 2>/dev/null`;
  if ($islilo =~ /$Loader/o) {
    $bootdevice = $device;
  }
  if (defined($rootdevice) && defined($bootdevice)) {
    last;
  }
}
close(FSTAB);

if (! defined($rootdevice)) {
  my $answer;
  print "Could not find where the current root file system is mounted!\n";
  print "Please make some arrangement for your system to boot the new \n";
  print "kernel (like running LILO, loadlin, SILO, QUIK, or getting a \n";
  print "boot floppy).                                                \n"; 
  print "Please hit return to continue.                               \n";
  $answer = <STDIN>;
  exit (0);
}
else {
  $rootdisk = $rootdevice;
  $rootdisk =~ s/[0-9]+$//;
  $rootpartition = $rootdevice;
  $rootpartition =~ s/$rootdisk//;
}

print "A new kernel image has been installed, and usually that means  \n";
print "that some action has to be taken to make sure that the new     \n";
print "kernel image is used next time the machine boots. Usually,     \n";
print "this entails running a ``bootloader'' like grub, SILO, loadlin,\n";
print "LILO, QUIK, or booting from a floppy.                        \n\n";

if ( ! -x "/sbin/$loader" ) {
  print "Hmm. $Loader";
  printf " (LInux LOader)"                if $loader =~ /lilo/i;
  printf " (Sparc Improved Linux lOader)" if $loader =~ /silo/i;
  printf " (QUIK: PowerMac Boot Loader)"  if $loader =~ /quik/i;
  printf ", which is the boot loader I    \n";
  print "have additional help for, is not installed (it is, after all,\n";
  print "just one of many options. I am assuming you have made some   \n"; 
  print "other arrangement for your system to boot the new kernel     \n";
  print "Please hit return to continue.                               \n";
  my $answer = <STDIN>;
  exit (0) unless defined $rootdevice;
  exit (0) if $loader =~ /silo/i; # No idea how to make non SILO floppies
  exit (0) if $loader =~ /quik/i;

  print "I can make a non-LILO diskette instead, but it won't be as useful.\n";

  if (&ask_y("Would you like to create a boot floppy now")) {
    &makefloppy();
  }
  exit(0);
}

@boilerplate = (
    "compact\n",
    "install=/boot/boot.b",
    "\nmap=/boot/map\n",
    "vga=normal\n",
    "delay=20\n",
    "image=" . $imagedir . "$kimage\n",
    "label=Linux\n",
    "read-only\n"
);

@silotemplate = (
   "partition=$rootpartition\n",
   "root=$rootdevice\n",
   "timeout=100\n",
   "image=" . $imagedir . "$kimage\n",
   "\tlabel=Linux\n",
   "\tread-only\n",
   "other=1\n",
   "\tbootblock=" . $rootpartition .  "/boot/old.b\n",
   "\tlabel=oldsys\n"
		);

@quiktemplate = (
   "partition=$rootpartition\n",
   "root=$rootdevice\n",
   "timeout=100\n",
   "image=" . $imagedir . "$kimage\n",
   "\tlabel=Linux\n",
   "\tread-only\n",
   "other=1\n",
   "\tbootblock=" . $rootpartition .  "/boot/old.b\n",
   "\tlabel=oldsys\n"
                );


print STDERR <<"EOMSG";
A new kernel image has been installed. 

$Loader sets up your system to boot Linux directly from your hard
disk, without the need for a boot floppy.

WARNING
If you are keeping another operating system or another version
of Linux on a separate disk partition, you should not have $Loader
install a boot block now. Wait until you read the $Loader documentation.
That is because installing a boot block now might make the other
system un-bootable. If you only want to run this version of Linux,
go ahead and install the boot block here. If it does not work, you
can still boot this system from a floppy.

EOMSG
;

if (&ask("Would you like to create a boot floppy now")) {
  &makefloppy();
}

if (-T "/etc/$loader.conf") {
  # Trust and use the existing lilo.conf.
  print "You already have a $Loader configuration in /etc/$loader.conf\n";
  if ( &ask_y("Install a boot block using the existing /etc/$loader.conf") ) { 
    my $ret = &run_lilo();
    exit $ret;
  }
  else {
    if (&ask("Wipe out your old $Loader configuration and make a new one")){
      rename("/etc/$loader.conf", "/etc/$loader.conf.OLD");
    }
    else {
      exit (0);
    }
  }
}

if (! &ask_y("Do you wish to set up Linux to boot from the hard disk")) {
  exit (0);
}

if ($loader =~ /lilo/io) {
  print <<EOF;

You must do three things to make the Linux system boot from the hard
disk. Install a partition boot record, install a master boot record,
and set the partition active. You will be asked to perform each of
these tasks. You may skip any or all of them, and perform them
manually later on
EOF
  ;
  
}

# If we get this far, we need to make a new lilo conf, and run lilo
&make_liloconf();

if (&ask_y("Install a partition boot block on partition $bootdevice")) {
  my $ret = &run_lilo();
  exit $ret if $ret;
}

if ($loader =~ /lilo/io) {
  print "\n";
  print "A master boot record is required to run the partition boot record.\n";
  if (-f "/boot/mbr.b") {
    print "If you are already using a boot manager, and want to keep it,\n";
    print "answer \"no\" to the following question. If you don't know\n";
    print "what a boot manager is or whether you have one, answer \"yes\".\n";
    if ( &ask_y("Install a master boot record (/boot/mbr.b) on $rootdisk")) {
      my $ret = system("dd if=/boot/mbr.b of=$rootdisk bs=444 count=1");
      if ($ret) {
	print "There was a problem copying the master boot record.\n";
	print "Please run \"dd if=/boot/mbr.b of=$rootdisk bs=444 count=1\"\n";
	print "by hand. Please hit return to continue.\n";
	my $ans = <STDIN>;
      }
    }
  }
  else {
    print "However, you do not seem to have /boot/mbr.b, provided by the\n";
    print "Debian package mbr.  I hope that your master boot record or \n";
    print "boot manager does boot the active partition.  If not, you have\n";
    print "to acquire the package mbr and install it. Please hit return to\n";
    print "proceed.\n";
    my $ans = <STDIN>;
  }
  print "\n";
  print "The master boot record will boot the active partition.\n";
  print "If you want your system to boot another operating system,\n";
  print "such as DOS or Windows, by default, answer \"no\" to the following\n";
  print "question. You may still use your boot manager or the master\n";
  print "boot record to boot Linux. If you want the system to boot Linux.\n";
  print "by default, answer \"yes\".\n";
  if ( &ask_y("Make $rootdevice the active partition") ) {
    my $ret = system("/sbin/activate $rootdisk $rootpartition");
    if ($ret) {
      print "There was an error trying to activate $rootdevice.\n";
      print "Please run \"/sbin/activate $rootdisk $rootpartition\"\n";
      print "by hand. Please hit return to proceed.\n";
      my $ans = <STDIN>;
    }
  }
  else {
    print "\n";
    print "OK. If you installed the master boot record, and the partition\n";
    print "boot record, you may boot Linux by holding down the shift key\n";
    print "as the system boots, and then pressing the $rootpartition key\n";
    print "when you see the \"1234F:\" prompt.\n";
    print "";
    print "For more information, see /usr/doc/mbr/README, and the files\n";
    print "in the /usr/doc/$loader directory.\n";
  }
}
else {
  if (-f "/boot/old.b") {
    print "$loader has overwritten the original boot loader and saved it under\n";
    print "/boot/old.b.  You can boot your old system (if any) using the\n";
    print "oldsys label at the $loader prompt.\n";
  }
}

sub ask {
  my $answer;
  print @_,"? [No] ";
  $answer=<STDIN>;
  return ( $answer =~ /^\s*y/i );
}

sub ask_y {
  my $answer;
  print @_,"? [Yes] ";
  $answer=<STDIN>;
  return ( $answer !~ /^\s*n/i );
}

sub makefloppy {
  my $answer;
  my $done = 0;
  my $drive = 0;
  
  print <<EO_MSG_A;

This process needs a formatted floppy. Please note that an unformatted
floppy will cause this process to fail, and may well need a reboot to
fix, and unfortunately, the system is not bootable yet.

The first thing to determine is which floppy drive you wish to use.
For most people, the default, which is the the default floppy drive,
referred to as /dev/fd0, or A: would work.  Some people may want the
second floppy drive which is drive 1, or /dev/fd1, or B:. 
(Theoretically there there could be 8 floppy drives on a machine) If
in doubt, accept the default [0], which should work in most cases.

EO_MSG_A
  ;
  
  print "Which floppy drive [0-7] do you want to use? [0] ";
  $answer=<STDIN>;
  if ($answer =~ m/^\s*(\d+)\s*$/) {
    $drive = $1;
  }
  print "\nOk, using drive at /dev/fd$drive.\n\n";
  
  if (-x "/usr/bin/superformat") {
      print "If there is no formatted floppy available, I could attempt\n";
      print "to format it for you.\n";
      if (&ask("Do you wish me to format the floppy")){
         my $ret;
	 my $format_command = '/usr/bin/superformat';
	 
         print "Insert a floppy diskette into your boot drive \n";
         print "(/dev/fd$drive) and press <Return> when ready:";
         $answer=<STDIN>;
        FMTFLOPPY: while (! $done) {
         DOFORMAT:{
              $ret = system $format_command, "/dev/fd$drive";
              last DOFORMAT if $ret;
              $done = 1;
           }
           if (! $done) {
	     print <<EO_MSG_B;

There was a problem formatting the floppy diskette in /dev/fd$drive

Please make sure that you inserted the disk in the correct drive and
that the disk is not write-protected.  Also, you may have to run
setfdprm for fdformat to work.

In some rare cases, it may mean a problem with the Floppy or the drive
it self (try formatting the floppy with
      % $format_command  /dev/fd$drive
manually to make sure if the problem persists).  In case the problem
persists, it maybe because you have an older fdformat which has a
problem auto- detecting the floppy drive.  Upgrading to the latest
fdutils may help, or maybe you need to run
      % setfdprm /dev/fd$drive 1440/1440 
(or something like that) or you may try some thing like
      % $format_command  /dev/fd0H1440
 or even 
      % $format_command  /dev/fd0u1440
manually which _may_ work. Or else, try a new floppy.

EO_MSG_B
  ;
	     
	     
             if (! &ask_y("Would you like to try again")) {
		print "\n";
		print "If there are no pre-formatted floppies available, \n";
		print "you should stop right here. \n";
		if (! &ask_y("Do you have a blank pre-formatted floppy")){
		  print "Ok, aborting.\n";
		  print "\n";
		  return 1;
		}
		print "\n";
              	last FMTFLOPPY;
             }
           }
         }
      }
  }
  else {
       print "If there are no pre-formatted floppies available, you\n";
       print "should stop right here. \n";
      if (! &ask_y("Do you have a blank pre-formatted floppy")){
	print "Ok, aborting.\n";
        return 1;
      }
  }
  if (!$done) {
      print "\n";
      print "Insert a (formatted) floppy diskette into your boot drive\n";
      print "(/dev/fd$drive) and press <Return> when ready:";
      $answer=<STDIN>;
  }
  $done=0;
  while (! $done) {
  MKBOOT:{
      my $ret;
      if ($loader =~ /lilo/io) {
	if ($no_symlink || $reverse_symlink) {
	  $ret = 
	    system '/bin/dd', "if=$imagedir" . "$kimage", "of=/dev/fd$drive";
	}
	else {
	  $ret = 
	    system '/bin/dd', "if=$realimageloc" . "$kimage-$version",  
	    "of=/dev/fd$drive";
	}
	last MKBOOT if $ret;
	$ret = system '/usr/sbin/rdev', "/dev/fd$drive", "$rootdevice";
	last MKBOOT if $ret;
	$ret = system '/usr/sbin/rdev', '-R', "/dev/fd$drive", '1';
      }
      else {
	$ret = &silo_floppy( $drive );
      }
      last MKBOOT if $ret;
      $done = 1;
      print "\n";
    }
    if (! $done) {
      print "\nThere was a problem creating the boot diskette in \n";
      print "/dev/fd$drive\n.";
      print "Please make sure that you inserted the diskette into the\n";
      print "correct drive and that the diskette is not write-protected.\n";
      print "In some rare cases, it may mean a problem with the\n";
      print "Floppy or the drive it self.\n";
      if (! &ask_y("Would you like to try again")) {
	$done = 1;
      }
      else {
	# don't display the next message if no more tries
	print "\n";
	print "Insert a (formatted) floppy diskette into your boot drive\n";
	print "/dev/fd$drive and press <Return> when ready:";
	$answer=<STDIN>;
      }
    }
  }
}

sub silo_floppy {
  my $drive = shift;
  my $mountpoint = "/var/lib/kernel.mntpoint.$$";
  $ret = system '/sbin/mke2fs', "/dev/fd$drive";
  return $ret if $ret;
  $ret = mkdir $mountpoint, 0755;
  return $ret if $ret;
  $ret = system '/bin/mount', '-t', 'ext2', "/dev/fd$drive", $mountpoint;
  do { rmdir $mountpoint; return $ret } if $ret;
  do {
    mkdir $mountpoint . "/boot", 0755;
    last unless system '/bin/cp', '/boot/first.b', $mountpoint . '/boot';
    last unless system '/bin/cp', '/boot/second.b', $mountpoint . '/boot';
    if ($no_symlink || $reverse_symlink) {
      $ret = system '/bin/cp', $imagedir . $kimage, $mountpoint . '/linux';
    }
    else {
      $ret = system '/bin/cp', "$realimageloc" . "$kimage-$version",
                       $mountpoint . '/linux';
    }
    last if $ret;
    mkdir( $mountpoint . "/etc", 0755 ) || last;
    open SILO, ">$mountpoint/etc/silo.conf" || last;
    print SILO
       "partition=1\n",
       "root=/dev/fd$drive\n",
       "read-write\n",
       "timeout=100\n",        # 10s
       "image=/linux\n",
       "\tlabel=Linux\n",
       "\tappend=root=$rootdevice\n";
    close SILO;
    $ret = system '/sbin/silo', '-r', $mountpoint;
  };
  system '/bin/umount', $mountpoint;
  rmdir $mountpoint;
  return $ret;
}


sub make_liloconf {
  # Create a lilo.conf if one doesn't exist.
  if (!defined($bootdevice)) {
    print "\nHmm... I can't determine which partition to put the \n";
    print "partition boot record on. I'm defaulting to the $rootdevice\n";
    print "which is where the root file system lives.\n";
    $bootdevice = $rootdevice;
  }
  
  open(CONF, ">/etc/$loader.conf");
  if ($loader =~ /lilo/io) {
    print CONF "boot=".$bootdevice, "\n", "root=".$rootdevice, "\n", 
               @boilerplate;
  }
  else {
    print CONF @silotemplate;
  }
  close(CONF);
  chmod("/etc/$loader.conf", 0644);
  chown("/etc/$loader.conf", 0, 0);
}

sub run_lilo (){
  my $ret;
  if ($loader =~ /lilo/io) {
    print "Testing lilo.conf ... \n";
    unlink $temp_file_name;                        # security
    $ret = system("/sbin/lilo -t >$temp_file_name");
    if ($ret) {
      my $ans;
      print "There was an error with running $loader in test mode, a log is \n";
      print "available in $temp_file_name. Please edit /etc/$loader.conf\n";
      print "manually and re-run $loader, or make other arrangements to boot \n";
      print "your machine. \n\t Please hit return to continue";
      $ans = <STDIN>;
      return $ret;
    }
    unlink "$temp_file_name";
    print "Testing successful. Installing the partition boot sector... \n";
  }
  
  $ret = system("/sbin/$loader >$temp_file_name");
  if ($ret) {
    my $ans;
    print "There was an error with running $loader, a log file is \n";
    print "available in file $temp_file_name.  Please edit /etc/$loader.conf\n";
    print "manually and re-run $loader, or make other arrangements to boot \n";
    print "your machine. \n\t Please hit return to continue";
    $ans = <STDIN>;
    return $ret;
  }
  unlink $temp_file_name;                        
  print "Installation successful.\n";
  return 0;
}

exit 0;

__END__

